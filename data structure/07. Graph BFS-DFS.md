# 07. Graph BFS-DFS

## 7.1 DFS (Depth-First Search)

DFS는 그래프를 **깊이 우선으로 탐색하는 알고리즘**이다. 한 노드를 방문하면, 그 노드에서 갈 수 있는 곳까지 **최대한 깊이** 들어갔다가, 더 이상 갈 곳이 없으면 **다시 되돌아와서 다른 경로를 탐색하는 방식**이다.

탐색 순서는 스택(Stack) 또는 재귀 함수(함수 호출 스택)를 이용해 구현할 수 있다. 스택에 현재 노드를 저장하고, 방문할 수 있는 이웃 노드를 찾아가며 탐색을 계속한다.

동작 과정은 다음과 같다:

1. 시작 노드를 스택에 넣고 방문 표시를 한다.
    
2. 스택의 맨 위 노드에서 갈 수 있는 인접 노드를 하나 선택한다.
    
3. 아직 방문하지 않았다면 스택에 넣고 방문 표시를 한다.
    
4. 더 이상 갈 수 없으면 스택에서 꺼낸다.
    
5. 스택이 빌 때까지 반복한다.
    

DFS의 시간 복잡도는 다음과 같다:

- 인접 리스트 사용 시: $O(V + E)$
    
- 인접 행렬 사용 시: $O(V^2)$  
    (V는 정점 수, E는 간선 수)
    

장점:

- 구현이 간단하고 직관적이다.
    
- **경로 탐색, 사이클 여부 확인** 등에 유용하다.
    
- 재귀로도 쉽게 구현할 수 있다.
    

단점:

- 최단 거리를 보장하지 않는다.
    
- 깊이가 깊은 그래프에서는 스택 오버플로우가 날 수 있다.
    

DFS는 미로 탐색, 퍼즐 풀이, 백트래킹 등에서 자주 사용되며, **그래프의 구조를 분석하거나 모든 경우를 탐색**할 때 적합한 알고리즘이다.

## 7.2 BFS (Breadth-First Search)

BFS는 그래프를 **너비 우선으로 탐색하는 알고리즘**이다. 시작 노드에서 가까운 노드부터 차례대로 탐색하며, 모든 이웃을 먼저 방문한 후 그다음 단계의 노드로 넘어가는 방식이다.

탐색 순서는 큐(Queue)를 사용해 구현한다. 한 노드를 방문하면 그 노드와 연결된 모든 인접 노드를 큐에 넣고, 큐에서 꺼낸 노드를 기준으로 다시 인접 노드를 탐색한다.

동작 과정은 다음과 같다:

1. 시작 노드를 큐에 넣고 방문 표시를 한다.
    
2. 큐에서 노드를 하나 꺼낸다.
    
3. 그 노드와 인접한 노드들 중 아직 방문하지 않은 노드를 모두 큐에 넣고 방문 표시를 한다.
    
4. 큐가 빌 때까지 반복한다.
    

BFS의 시간 복잡도는 다음과 같다:

- 인접 리스트 사용 시: $O(V + E)$
    
- 인접 행렬 사용 시: $O(V^2)$
    

장점:

- **최단 경로**를 구할 수 있다. (모든 간선의 가중치가 같을 때)
    
- 탐색 순서가 일정해서 예측이 쉽다.
    

단점:

- 큐를 사용하기 때문에 공간을 많이 사용할 수 있다.
    
- 트리나 그래프가 매우 클 경우, 메모리 사용량이 증가한다.
    