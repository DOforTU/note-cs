# 03. Tree

## 3.1 Binary Search

Binary Search는 **정렬된 배열**에서 원하는 값을 빠르게 찾는 탐색 알고리즘이다. 순차적으로 하나하나 찾는 방법보다 훨씬 빠르며, 시간 복잡도는 $O(\log n)$이다.

이진 탐색의 기본 아이디어는 다음과 같다:

1. 배열의 가운데 값을 확인한다.
    
2. 찾고자 하는 값이 가운데 값보다 작으면 왼쪽 절반에서 다시 탐색하고, 크면 오른쪽 절반에서 탐색한다.
    
3. 이 과정을 반복하여 값을 찾거나, 더 이상 범위가 없을 때까지 진행한다.
    

예를 들어 `[1, 3, 5, 7, 9]`라는 정렬된 배열에서 `5`를 찾는 경우, 가운데 값인 `5`를 바로 확인하고 탐색을 종료할 수 있다. 만약 `3`을 찾는다면, `5`보다 작기 때문에 왼쪽 절반인 `[1, 3]`에서 다시 탐색하게 된다.

Binary Search는 다음과 같은 조건에서만 사용할 수 있다:

- **데이터가 정렬되어 있어야 한다**.
    
- **인덱스를 통한 접근이 가능해야 한다**. (예: 배열)
    

이진 탐색은 다양한 곳에서 사용된다. 예를 들어, 특정 값의 존재 여부를 확인하거나, 조건을 만족하는 최소/최대값을 찾을 때도 사용된다. 이럴 경우 **이진 탐색의 응용**이라고 부른다.

## 3.2 Union

Union은 보통 **서로소 집합(Disjoint Set)** 자료구조에서 사용하는 개념이다. 여러 개의 원소가 있을 때, 각각이 어떤 그룹(또는 집합)에 속해 있는지를 빠르게 파악하고, 두 그룹을 하나로 합치는 작업을 말한다.

이 자료구조는 보통 **Union-Find** 또는 **Disjoint Set Union (DSU)** 이라고 불린다. 크게 두 가지 연산을 지원한다:

1. **Find**: 어떤 원소가 속한 집합의 대표 값을 찾는다.
    
2. **Union**: 두 원소가 속한 집합을 하나로 합친다.
    

각 원소는 트리 형태로 연결되어 있고, 루트 노드가 그 집합의 대표가 된다. 처음에는 각 원소가 자기 자신만 포함한 집합으로 시작하며, Union 연산을 통해 점점 큰 집합으로 병합된다.

예를 들어, `1`, `2`, `3`이 각각 따로 있다가 `Union(1, 2)`를 하면 두 원소는 같은 집합이 된다. 이후 `Union(2, 3)`을 하면 세 개의 원소가 모두 하나의 집합에 속하게 된다.

Union-Find는 다음과 같은 상황에서 유용하게 쓰인다:

- **그래프에서 사이클 판별**
    
- **네트워크 연결 여부 확인**
    
- **최소 스패닝 트리 알고리즘(예: Kruskal’s Algorithm)**
    

성능 향상을 위해 **경로 압축(Path Compression)** 과 **랭크 기반 합치기(Union by Rank)** 기법을 함께 사용하면, 거의 상수 시간에 가까운 성능($O(\alpha(n))$)으로 동작할 수 있다. 여기서 $\alpha(n)$은 아커만 함수의 역함수이며, 매우 느리게 증가하는 함수이다.

>  아커만 함수는 수학적으로 정의된 매우 빠르게 증가하는 함수이다. 예를 들어 일반적인 함수들이 $n$, $n^2$, $2^n$처럼 증가한다면, 아커만 함수는 이보다 훨씬 빠르게 커진다. 그래서 그 역함수인 $\alpha(n)$은 사실상 대부분의 현실적인 입력에서 5 이하의 값을 가지며, 거의 상수처럼 취급할 수 있다.

## 3.3 AVL Tree

AVL Tree는 **자기 균형 이진 탐색 트리(Self-balancing Binary Search Tree)** 의 한 종류이다. 데이터가 삽입되거나 삭제된 후에도 항상 트리의 균형을 유지하는 것이 특징이다.

일반적인 이진 탐색 트리는 한쪽으로 치우칠 수 있어서, 최악의 경우에는 성능이 $O(n)$까지 나빠질 수 있다. AVL Tree는 이런 문제를 해결하기 위해 **각 노드의 높이 차이(balance factor)를 1 이하로 유지**한다.

각 노드는 다음과 같은 정보를 가진다:

- 값 (데이터)
    
- 왼쪽 자식, 오른쪽 자식
    
- 높이(height)
    

노드가 삽입되거나 삭제될 때 균형이 무너지면, 회전(Rotation)을 통해 트리의 균형을 되찾는다. 회전에는 다음과 같은 4가지 방식이 있다:

1. **LL 회전**: 왼쪽-왼쪽 불균형
    
2. **RR 회전**: 오른쪽-오른쪽 불균형
    
3. **LR 회전**: 왼쪽-오른쪽 불균형
    
4. **RL 회전**: 오른쪽-왼쪽 불균형
    

이러한 회전을 통해 AVL Tree는 항상 $O(\log n)$의 높이를 유지하며, 삽입, 삭제, 탐색 모두 $O(\log n)$의 시간 복잡도를 보장한다.

AVL Tree는 다음과 같은 경우에 유용하게 사용된다:

- 삽입과 삭제가 자주 일어나는 경우에도 빠른 탐색 성능을 유지해야 할 때
    
- 정렬된 데이터가 순서대로 들어와도 트리의 성능이 나빠지지 않아야 할 때
    

비슷한 구조로는 **Red-Black Tree**가 있으며, 둘 다 균형을 유지하는 방법이 다르지만 목적은 같다. AVL Tree는 균형을 더 엄격하게 유지하는 대신 회전이 자주 발생하며, Red-Black Tree는 균형 조건이 느슨해 회전 횟수가 적다.