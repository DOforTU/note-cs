# 01. Array and List

## 1.1 Dynamic Array

Dynamic Array는 크기를 자동으로 조절할 수 있는 배열이다. 일반적인 배열은 처음에 크기를 정해두면 이후에는 그 크기를 바꿀 수 없다는 단점이 있다. 하지만 Dynamic Array는 데이터를 추가하면서 공간이 부족해질 경우, 더 큰 공간을 새로 만들고 기존 데이터를 복사해서 이어서 사용할 수 있다.

처음에는 작은 크기의 배열을 생성하고 데이터를 저장한다. 배열이 가득 차면, 보통 기존 크기의 두 배만큼 큰 배열을 새로 만들고 모든 요소를 복사한다. 이 과정은 시간이 오래 걸릴 수 있지만, 자주 일어나는 것은 아니기 때문에 평균적으로는 빠르게 동작한다. 이러한 전략을 **공간 확장 전략**이라고 부른다.

예를 들어 크기 4짜리 배열에 4개의 요소가 모두 들어간 상태에서 하나를 더 추가하면, 새로운 크기 8짜리 배열을 만들고 기존 4개의 데이터를 옮긴 후 새 데이터를 넣는다.

Dynamic Array는 다음과 같은 특징을 가진다:

- **인덱스를 통한 접근**이 빠르다. 원하는 위치의 값을 바로 읽을 수 있으므로 $O(1)$의 시간 복잡도를 가진다.
    
- **데이터 추가**는 평균적으로 빠르지만, 공간 확장이 일어나는 경우는 $O(n)$의 시간이 걸릴 수 있다.
    
- **중간 삽입이나 삭제**는 뒤에 있는 요소들을 모두 이동시켜야 하므로 느리다. 이 경우 시간 복잡도는 $O(n)$이다.
    

대표적인 예시로는 파이썬의 `list`, 자바의 `ArrayList`, C++의 `vector` 등이 있다. 이들은 모두 내부적으로 Dynamic Array를 사용한다.

## 1.2 Linked List

Linked List는 데이터를 연결된 형태로 저장하는 자료구조이다. 배열과 달리 데이터를 연속된 공간에 저장하지 않아도 되며, 각 요소는 다음 요소의 위치를 가리키는 포인터를 가지고 있다.

Linked List는 **노드(Node)** 라는 단위로 구성된다. 하나의 노드는 보통 두 가지 정보를 가진다:

1. 실제 데이터
    
2. 다음 노드를 가리키는 포인터
    

가장 앞에 있는 노드를 **head**, 마지막 노드를 **tail**이라고 부른다. 마지막 노드의 포인터는 아무것도 가리키지 않는다.

Linked List의 특징은 다음과 같다:

- **중간 삽입과 삭제**가 빠르다. 노드 하나를 삭제하거나 새로운 노드를 삽입하려면 포인터만 변경하면 되기 때문에 $O(1)$의 시간 복잡도를 가진다.
    
- 하지만 **임의 접근**이 불가능하다. 특정 위치의 데이터를 읽기 위해서는 첫 번째 노드부터 하나씩 따라가야 하므로 $O(n)$의 시간이 걸린다.
    
- **메모리 사용 효율**은 낮을 수 있다. 각 노드마다 데이터를 제외한 포인터를 저장해야 하기 때문이다.
    
- **이중 연결 리스트(Doubly Linked List)** 는 양쪽 방향으로 이동할 수 있도록 이전 노드 포인터도 함께 저장한다.
    

예를 들어, "A → B → C"라는 Linked List가 있다고 하자. 여기서 B 다음에 D를 삽입하고 싶다면, B의 포인터를 D로 바꾸고, D의 포인터를 C로 연결하면 된다. 이렇게 하면 전체 구조가 "A → B → D → C"로 변경된다.

Linked List는 데이터 추가/삭제가 잦은 경우에 적합하며, 특히 크기를 미리 알 수 없는 상황에서 유용하게 사용된다. 