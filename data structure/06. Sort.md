# 06. Sort


## 6.1 Selection Sort

Selection Sort는 **가장 작은 값을 선택해서 앞에 차례로 배치하는 방식의 정렬 알고리즘**이다. 정렬되지 않은 구간에서 가장 작은 값을 찾아서 맨 앞의 값과 교환하고, 그다음 구간에서 또 가장 작은 값을 찾아 두 번째와 교환하는 식으로 동작한다.

동작 과정은 다음과 같다:

1. 전체 배열 중에서 가장 작은 값을 찾는다.
    
2. 그 값을 맨 앞 값과 교환한다.
    
3. 나머지 구간에서도 같은 방식으로 반복한다.
    

예를 들어 `[5, 3, 4, 1, 2]`가 있을 때, 가장 작은 값 `1`을 찾아서 첫 번째 값 `5`와 바꾸고, 다음에는 `[1, 3, 4, 5, 2]`에서 `2`를 찾아 두 번째 값 `3`과 바꾸는 식이다.

Selection Sort의 시간 복잡도는 다음과 같다:

- 최악, 평균, 최선 모두 $O(n^2)$
    
- 교환 횟수는 최대 $n - 1$번으로 적지만, 비교는 항상 $n(n - 1)/2$번 수행한다
    

장점:

- 구현이 간단하다.
    
- 교환 횟수가 적어, 교환 비용이 큰 환경에서는 상대적으로 유리하다.
    

단점:

- 비교 횟수가 많아 데이터가 많을수록 느리다.
    
- 안정 정렬이 아니다. 같은 값의 순서가 바뀔 수 있다.
    

## 6.2 Insertion Sort

Insertion Sort는 **정렬된 부분에 새로운 값을 끼워 넣는 방식의 정렬 알고리즘**이다. 사람이 카드를 정렬할 때 손에 든 카드 중에서 알맞은 위치에 카드를 끼워 넣는 방식과 비슷하다.

동작 과정은 다음과 같다:

1. 두 번째 원소부터 시작해서, 그 값을 앞에 있는 정렬된 부분과 비교한다.
    
2. 알맞은 위치를 찾아 그 자리에 삽입한다. 필요하면 기존 값들을 한 칸씩 뒤로 민다.
    
3. 이 과정을 끝까지 반복한다.
    

예를 들어 `[5, 3, 4, 1, 2]`에서 `3`은 `5`보다 작으므로 앞에 끼워 넣고, `[3, 5, 4, 1, 2]`가 된다. 다음으로 `4`는 `5`보다 작고 `3`보다는 크므로 `5`를 뒤로 밀고 `4`를 가운데 넣는다.

시간 복잡도는 다음과 같다:

- 최악, 평균: $O(n^2)$
    
- 최선 (이미 정렬된 경우): $O(n)$
    

장점:

- 구현이 간단하다.
    
- 데이터가 거의 정렬된 상태라면 매우 빠르게 동작한다.
    
- 안정 정렬이다. 같은 값의 순서가 유지된다.
    
- 추가 공간을 사용하지 않는다.
    

단점:

- 많은 데이터를 정렬할 때는 느리다.
    
- 삽입 시, 많은 데이터를 이동시켜야 할 수 있다.
    

## 6.3 Shell Sort

Shell Sort는 Insertion Sort를 개선한 알고리즘이다. Insertion Sort는 인접한 값을 비교하면서 한 칸씩만 이동하지만, Shell Sort는 **멀리 떨어진 요소끼리 비교해 더 빠르게 정렬**할 수 있도록 도와준다. 이 방식은 정렬 속도를 향상시켜 Insertion Sort의 단점을 보완한다.

기본 아이디어는 다음과 같다:

1. 전체 배열을 일정한 간격(`gap`)으로 나누어 부분적으로 정렬한다.
    
2. 점점 간격을 줄여가며, 마지막에는 간격이 1이 되도록 만든다. 이때는 Insertion Sort와 동일하게 작동하지만, 이미 어느 정도 정렬되어 있기 때문에 훨씬 빠르다.
    

예를 들어 `[8, 5, 3, 7, 6, 2, 4, 1]`이 있다면 처음에는 `gap = 4`로 시작하여 `[8, 6]`, `[5, 2]`, `[3, 4]`, `[7, 1]`씩 떨어진 쌍끼리 정렬한다. 이후 `gap = 2`, `gap = 1` 순으로 점점 좁혀가며 정렬을 마무리한다.

시간 복잡도는 정확히 정해져 있지 않다. 사용하는 간격에 따라 달라지며, 일반적으로는 다음과 같다:

- 평균: $O(n^{1.25})$ ~ $O(n^{1.5})$
    
- 최악: $O(n^2)$
    
- 최선: $O(n \log n)$에 근접 (Hibbard, Sedgewick 등의 간격 수열 사용 시)
    

장점:

- 단순하면서도 Insertion Sort보다 훨씬 빠르다.
    
- 추가 메모리를 사용하지 않는다.
    
- 구현이 비교적 쉽고, 실무에서도 사용할 수 있다.
    

단점:

- 안정 정렬이 아니다. 같은 값의 순서가 바뀔 수 있다.
    
- 성능은 간격 수열에 따라 크게 달라진다.
    

## 6.4 Heap Sort

Heap Sort는 **힙(Heap) 자료구조를 기반으로 하는 정렬 알고리즘**이다. 힙은 부모 노드가 자식 노드보다 항상 크거나(최대 힙), 작아야(최소 힙) 하는 이진 트리 구조이다. Heap Sort는 이 특성을 활용해 가장 큰 값(또는 가장 작은 값)을 효율적으로 꺼내며 정렬을 수행한다.

기본 동작 방식은 다음과 같다:

1. 주어진 데이터를 **최대 힙**으로 만든다. 그러면 루트에는 항상 가장 큰 값이 위치한다.
    
2. 루트 값을 배열의 맨 끝으로 보내고, 힙의 크기를 줄인 후 다시 힙 구조를 재정비한다.
    
3. 이 과정을 반복하여 큰 값부터 차례로 뒤로 보내면서 전체 배열을 정렬한다.
    

예를 들어 `[4, 10, 3, 5, 1]`이라는 배열이 있다면, 최대 힙을 만들면 `10`이 루트가 된다. 이를 맨 뒤로 보내고 나머지로 다시 힙을 구성하는 과정을 반복한다.

Heap Sort의 시간 복잡도는 다음과 같다:

- 최악, 평균, 최선 모두 $O(n \log n)$
    
- 추가 메모리 사용 없이 정렬 가능 (in-place 정렬)
    

장점:

- 시간 복잡도가 안정적이며, 최악의 경우에도 $O(n \log n)$을 보장한다.
    
- 추가 메모리 공간이 거의 필요 없다.
    

단점:

- 안정 정렬이 아니다. 같은 값의 순서가 바뀔 수 있다.
    
- 힙을 구성하고 유지하는 과정이 느릴 수 있어, 실제 속도는 Quick Sort보다 느릴 수 있다.
    

## 6.5 Quick Sort

Quick Sort는 **분할 정복(Divide and Conquer)** 전략을 사용하는 매우 빠른 정렬 알고리즘이다. 실제로 대부분의 상황에서 가장 빠르게 작동하는 정렬 중 하나이며, 대부분의 프로그래밍 언어에서 표준 정렬 알고리즘으로 사용된다.

기본 아이디어는 다음과 같다:

1. **기준점(pivot)**을 하나 선택한다.
    
2. 배열을 pivot보다 작은 값과 큰 값으로 나눈다.
    
3. 나뉜 두 구간에 대해 Quick Sort를 재귀적으로 반복한다.
    

예를 들어 `[6, 3, 8, 5, 2]`에서 `5`를 pivot으로 선택하면 `[3, 2]`와 `[6, 8]`로 나뉜다. 이 두 배열에 다시 Quick Sort를 적용하면 된다.

Quick Sort의 시간 복잡도는 다음과 같다:

- 평균: $O(n \log n)$
    
- 최악: $O(n^2)$ (pivot을 항상 가장 작거나 큰 값으로 고르면 발생)
    
- 최선: $O(n \log n)$
    

하지만 **무작위로 pivot을 선택하거나 중앙값을 사용하면 평균적으로 매우 빠르게 작동**하여, 실제로는 최악의 경우가 거의 발생하지 않는다.

장점:

- 정렬 속도가 매우 빠르다.
    
- 대부분의 경우 Merge Sort보다 실질적인 성능이 좋다.
    

단점:

- 최악의 경우 $O(n^2)$이 될 수 있다.
    
- 추가 공간을 적게 사용하긴 하지만, 재귀 호출이 깊어질 수 있다.
    
- 안정 정렬이 아니다.
    

## 6.6 Merge Sort

Merge Sort는 **분할 정복(Divide and Conquer)** 기법을 사용하는 안정적인 정렬 알고리즘이다. 배열을 반으로 계속 나눈 다음, 정렬된 배열을 합치며 정렬을 완성하는 방식이다.

동작 과정은 다음과 같다:

1. 배열을 반으로 나눈다.
    
2. 각 절반을 재귀적으로 Merge Sort를 이용해 정렬한다.
    
3. 정렬된 두 배열을 **하나의 정렬된 배열로 병합(merge)**한다.
    

예를 들어 `[5, 3, 8, 4, 2]`라는 배열이 있다면, 먼저 `[5, 3]`, `[8, 4, 2]`로 나누고, 각각 정렬한 뒤 `[3, 5]`와 `[2, 4, 8]`을 다시 합쳐 최종 정렬을 완성한다.

Merge Sort의 시간 복잡도는 다음과 같다:

- 최악, 평균, 최선 모두 $O(n \log n)$
    
- 정렬 품질이 일정하며, 안정 정렬이다.
    

장점:

- 정렬 성능이 안정적이다.
    
- 안정 정렬이므로 같은 값의 순서가 유지된다.
    
- Linked List처럼 포인터 기반 자료구조에서도 성능이 좋다.
    

단점:

- 추가 메모리 공간이 필요하다. 배열을 병합할 때 새로운 배열을 생성해야 하기 때문이다.
    
- In-place 정렬이 아니라 메모리 제한이 있는 환경에서는 불리할 수 있다.
    

Merge Sort는 안정성과 예측 가능한 성능 때문에 대용량 정렬에서 널리 사용되며, 내부적으로 정렬 알고리즘의 기반으로 쓰이는 경우도 많다. 파이썬의 `sorted()` 함수도 Merge Sort 기반 알고리즘(Timsort)을 사용한다.