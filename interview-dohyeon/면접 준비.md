
### ✅ 기술 역량

**1. NestJS로 프로젝트를 진행하며 가장 어려웠던 점은 무엇이었고, 어떻게 해결했나요?**

> NestJS의 DI(Dependency Injection) 구조와 모듈 시스템에 처음에는 익숙하지 않아, 컴포넌트 간 의존성 관리가 복잡하게 느껴졌습니다. 공식 문서와 커뮤니티 예제를 분석하면서 모듈 간 분리와 의존성 주입 원리를 체계적으로 학습했고, 프로젝트를 리팩토링하면서 모듈화 설계 역량을 키울 수 있었습니다.

**2. FastAPI와 PyTorch를 연동하여 모델 서빙을 구현하신 경험이 있다고 했는데, 어떤 구조로 API를 설계하셨나요?**

> 모델 로딩 시점에 `startup event`를 활용해 PyTorch 모델을 메모리에 상주시켰고, `POST` 요청을 통해 입력 데이터를 받아 전처리한 뒤 예측 결과를 반환하는 구조로 설계했습니다. 예외 처리와 비동기 처리도 고려해 응답 속도와 안정성을 높였습니다.

**3. Docker와 EC2를 사용한 배포 환경을 어떻게 구성하셨는지 설명해 주세요.**

> 로컬 개발 환경에서 Docker Compose로 백엔드, 프론트, DB를 컨테이너화하고, EC2 인스턴스에 이미지를 푸시해 테스트 배포를 진행했습니다. `.env` 파일을 통해 환경별 설정을 분리했습니다.

**4. MySQL과의 연동 시 고려한 DB 설계 및 성능 최적화 방법은 무엇인가요?**

> 정규화를 기반으로 중복을 최소화하면서도, 조회가 빈번한 데이터에는 인덱싱을 통해 성능을 개선했습니다. 또한 N+1 문제를 방지하기 위해 TypeORM에서 `eager loading`과 `QueryBuilder`를 적절히 사용했습니다.

**5. WebSocket을 이용한 실시간 채팅 기능 구현에서 어떤 문제를 마주했으며, 어떻게 해결하셨나요?**

> 클라이언트와 서버 간 연결 유지 관리에서 heartbeat 설정이 없으면 연결이 끊기는 문제가 있었고, 사용자 인증을 WebSocket 연결 시 처리하는 방법도 고민이 필요했습니다. 이를 해결하기 위해 JWT 토큰을 연결 시점에 검증하고, Ping-Pong 메시지를 주기적으로 보내 연결 상태를 유지했습니다.

**6. React에서 상태 관리를 어떻게 처리하셨나요?**

> 컴포넌트가 복잡하지 않은 경우에는 `useState`, `useEffect`를 활용하고, 일정 이상 복잡해지는 경우에는 `Context API`와 `useReducer` 패턴을 조합했습니다. 특히 일정 플래너 기능에서는 상태 변경이 많아 `immer`를 활용해 불변성 유지에 신경 썼습니다.

**7. 지도 기반 기능 구현 시 Google Maps API를 어떻게 활용하셨고, 어떤 기술적 이슈가 있었나요?**

> 장소 정보를 기반으로 마커를 표시하고, 일정에 따라 이동하는 기능을 구현했습니다. 특히 많은 마커가 겹치는 문제를 `MarkerClusterer`로 해결했고, 지도의 중심 위치 자동 조절 기능도 추가해 사용자 경험을 개선했습니다.

**8. SentenceTransformer를 이용한 콘텐츠 추천 시스템은 어떤 방식으로 동작하나요?**

> 사용자 선호 키워드를 SentenceTransformer로 임베딩한 뒤, 콘텐츠 설명 임베딩과 코사인 유사도를 계산해 상위 콘텐츠를 추천하는 구조입니다. 장르, 플랫폼 같은 메타데이터는 필터링 조건으로 활용했습니다.

**9. 시계열 예측 모델(LSTM + Attention) 설계 시 중점적으로 고려한 요소는 무엇인가요?**

> 입력 시점의 중요도를 구분할 수 있도록 Attention 레이어를 추가했고, 학습 데이터에 포함된 이상치와 결측치 처리에 특히 신경 썼습니다. 예측 기간에 따라 성능 차이가 커서 단기/중기 모델을 따로 운용하는 방식으로 개선했습니다.

**10. 다이나믹 프로그래밍을 통해 요금제 최적화 로직을 구현하셨다고 했는데, 구체적인 알고리즘 구조를 설명해 주세요.**

> 콘텐츠별 요금제 커버 여부를 고려해 0-1 Knapsack 알고리즘 방식으로 구현했습니다. 예산 내에서 최대한 많은 콘텐츠를 커버하는 조합을 찾고, 추가로 사용자의 선호 장르와 일치하는 콘텐츠 수를 가중치로 반영했습니다.

---

### ✅ 협업 및 커뮤니케이션

**11. 팀 프로젝트에서 맡았던 역할 중 가장 주도적으로 기여한 부분은 무엇인가요?**

> Tripwith 프로젝트에서 플래너 기능과 사용자 인증, 추천 시스템 설계를 주도적으로 맡았습니다. 백엔드 API를 먼저 설계하고, 프론트와 연동되는 부분은 문서와 예제를 기반으로 소통해 구현 일정을 맞췄습니다.

**12. Git 기반 협업에서 브랜치 전략은 어떻게 구성하셨나요?**

> `main`, `dev`, 기능 단위 `feature/`, 이슈 단위 `issue/` 브랜치를 운영했습니다. PR 시 템플릿을 활용해 리뷰 포인트를 명확히 했고, 병합 전에 최소 1인 이상의 리뷰를 받는 방식을 정착시켰습니다.

**13. API 명세서나 문서화를 할 때 중요하게 생각하는 기준은 무엇인가요?**

> 사용자가 빠르게 이해하고 테스트할 수 있어야 한다고 생각합니다. Swagger나 Notion 문서를 활용해 요청/응답 예시, 에러 코드까지 상세히 명시했고, 문서와 실제 API가 일치하도록 지속적으로 관리했습니다.

**14. 비개발자와의 커뮤니케이션 시 어떤 방식으로 기술 내용을 전달하셨나요?**

> 기술 용어는 최소화하고, 실제 화면 변화나 예시를 중심으로 설명했습니다. 예를 들어 "이 API는 상품을 등록하면 실시간으로 다른 사용자에게 보입니다"처럼 기능 중심으로 접근했습니다.

**15. 코드 리뷰에서 피드백을 주고받는 과정에서 기억에 남는 경험이 있다면 소개해 주세요.**

> 초기에는 기능 구현 위주로만 리뷰를 받았지만, 팀원과의 논의를 통해 모듈화나 네이밍 규칙 같은 구조적인 부분도 주제로 삼기 시작했습니다. 이를 통해 코드 품질뿐 아니라 팀원 간 코드 이해도도 높아졌습니다.

---

### ✅ 문제 해결 능력

**16. 원두 가격 예측 프로젝트에서 감성 분석 결과가 효과적이지 않았던 문제를 어떻게 개선했나요?**

> 감성 분석 결과가 대부분 중립으로 분류돼 의미가 없었기에, 예측 구조 자체를 바꾸자는 제안을 했습니다. 예측 기간을 나눠서 병렬 모델을 만들고, 추세의 일치 여부를 기반으로 신뢰도를 높이는 전략을 도입했습니다.

**17. 예측 신뢰도를 높이기 위해 시도한 전략을 설명해 주세요.**

> 단기(7일)와 중기(14일) 예측 모델을 별도로 운용하고, 두 모델이 모두 상승 추세일 때만 ‘Buy’ 신호를 주는 방식으로 결정 기준을 강화했습니다. 이 방식은 실제 테스트에서도 일관된 결과를 보였습니다.

**18. Tripwith 프로젝트에서 추천 시스템 설계를 맡으셨는데, 추천 알고리즘 선택 과정에서 고려했던 요소는 무엇인가요?**

> 사용자의 여행 패턴 유사성을 비교하기 위해 편집 거리와 벡터 유사도를 함께 고려했습니다. 단순히 키워드 기반이 아니라, 일정을 구성하는 장소들의 시퀀스를 임베딩해 분석하는 방식으로 추천의 정밀도를 높였습니다.

---

### ✅ 인성 및 목표

**19. 민트기술 인턴십을 통해 구체적으로 어떤 점을 배우고 싶으신가요?**

> 지금까지는 테스트 수준의 배포만 경험했기 때문에, 실제 운영 환경에서의 코드 관리와 CI/CD, 모니터링, 장애 대응 프로세스를 직접 경험하고 싶습니다. 이를 통해 실무 개발자로서의 감각을 확실히 키우고 싶습니다.

**20. 기능 구현을 넘어 구조 개선에 관심이 많다고 하셨는데, 그와 관련된 경험이나 예시가 있다면 말씀해 주세요.**

> RentEase 프로젝트 초기에 기능 위주로 개발을 했지만, 이후 모듈 간 의존성이 강해 리팩토링이 어려웠습니다. 이를 해결하기 위해 의존성을 분리하고 서비스 계층을 도입해 유지보수성을 높였습니다. 이후 비슷한 구조를 다른 프로젝트에도 적용할 수 있었습니다.

---

## ✅ CS 지식 면접 질문 및 모범 답변

### 📌 1. RESTful API란 무엇인가요?

> **RESTful API**는 HTTP 프로토콜을 기반으로 클라이언트-서버 간의 통신을 설계하는 방식입니다. 자원을 URI로 식별하고, `GET`, `POST`, `PUT`, `DELETE`와 같은 메서드를 사용해 CRUD를 표현합니다. 상태를 서버에 저장하지 않는 **Stateless** 구조가 특징이며, 일관된 규칙으로 설계하면 유지보수와 확장성이 좋습니다.

---

### 📌 2. JWT(Json Web Token)의 구조와 보안 고려사항은?

> JWT는 세 부분: **Header**, **Payload**, **Signature**로 구성됩니다. Payload에 사용자 정보가 들어가며, 서버는 Signature를 통해 위조 여부를 검증합니다.  
> **보안 고려사항**으로는 Payload는 암호화되지 않기 때문에 민감한 정보는 넣지 않고, 토큰 탈취 방지를 위해 HTTPS 사용, 만료 시간 설정, 리프레시 토큰 사용 등이 필요합니다.

---

### 📌 3. HTTP와 HTTPS의 차이는?

> HTTPS는 HTTP에 **TLS(또는 SSL)** 암호화 계층이 추가된 프로토콜로, 클라이언트와 서버 간 통신 내용을 암호화해 제3자가 내용을 볼 수 없도록 합니다. HTTPS를 사용하면 데이터 무결성, 인증, 기밀성이 보장됩니다.

---

### 📌 4. 데이터베이스에서 인덱스(Index)는 어떻게 작동하나요?

> 인덱스는 데이터베이스 테이블의 특정 컬럼에 대한 **검색 속도를 높이는 자료구조**입니다. 일반적으로 B+ Tree 형태로 구현되며, 테이블 전체를 스캔하지 않고 필요한 레코드를 빠르게 찾을 수 있게 해줍니다.  
> 하지만 쓰기 성능이 저하될 수 있어, **조회가 많은 컬럼**에만 선택적으로 적용하는 것이 좋습니다.

---

### 📌 5. RDBMS와 NoSQL의 차이점은 무엇인가요?

> RDBMS는 정해진 **스키마**와 SQL 기반의 관계형 데이터베이스이며, 데이터 정합성과 트랜잭션 처리를 중시합니다.  
> NoSQL은 스키마가 유연하고, 수평 확장에 용이하며, 문서/키-값/그래프/컬럼 등 다양한 저장 방식이 있습니다. 대규모 비정형 데이터를 빠르게 처리하는 데 유리합니다.

---

### 📌 6. 트랜잭션의 4가지 속성(ACID)이란?

> - **Atomicity**: 모두 실행되거나 모두 실패
>     
> - **Consistency**: 일관성 있는 상태 유지
>     
> - **Isolation**: 트랜잭션 간 간섭 방지
>     
> - **Durability**: 완료된 변경은 영구적으로 저장
>     
> 
> 이 속성들은 DB의 신뢰성과 안정성을 보장합니다.

---

### 📌 7. Docker의 핵심 개념과 장점은?

> Docker는 애플리케이션을 **컨테이너** 단위로 격리해 배포할 수 있게 해주는 도구입니다.  
> 장점은 다음과 같습니다:
> 
> - 환경 불일치 문제 해결 (개발/운영 환경 통일)
>     
> - 경량화된 이미지로 빠른 배포
>     
> - 의존성 관리 용이
>     
> 
> 실제 프로젝트에서는 프론트/백/DB를 개별 컨테이너로 분리해 `docker-compose`로 통합 운영했습니다.

---

### 📌 8. OS에서 프로세스와 스레드의 차이는?

> - **프로세스**: 실행 중인 프로그램의 인스턴스로, 독립된 메모리 공간을 가짐
>     
> - **스레드**: 프로세스 내 작업 단위로, 메모리를 공유하며 더 가볍고 빠름
>     
> 
> 하나의 프로세스는 여러 스레드를 가질 수 있으며, 서버에서는 **멀티스레딩**으로 요청을 병렬 처리합니다.

---

### 📌 9. 정렬 알고리즘 중 시간 복잡도와 함께 자주 사용하는 것?

> 자주 사용하는 정렬 알고리즘:
> 
> - **Quick Sort**: 평균 O(n log n), 최악 O(n²), 일반적으로 가장 빠름
>     
> - **Merge Sort**: 항상 O(n log n), 안정 정렬
>     
> - **Heap Sort**: O(n log n), 공간 효율성
>     
> 
> 선택은 정렬 대상의 크기와 정렬 안정성 여부에 따라 달라집니다.

---

### 📌 10. 해시 테이블의 작동 원리와 충돌 해결 방법?

> 해시 테이블은 키를 해시 함수로 변환하여 배열의 인덱스로 사용해 빠른 검색이 가능하게 하는 자료구조입니다.  
> **충돌 해결** 방법에는:
> 
> - **체이닝(Chaining)**: 연결 리스트로 같은 인덱스 저장
>     
> - **개방 주소법(Open Addressing)**: 빈 슬롯을 찾아 저장
>     
> 
> 해시 함수의 품질과 충돌 해결 전략에 따라 성능이 달라집니다.

---

### 📌 11. 비동기와 동기 처리의 차이는?

> - **동기(Synchronous)**: 요청을 보내면 응답이 올 때까지 기다림
>     
> - **비동기(Asynchronous)**: 응답을 기다리지 않고 다음 작업 수행
>     
> 
> 비동기는 특히 **IO 처리(예: DB, 네트워크)** 에서 효율적이며, NestJS나 FastAPI에서는 `async/await`을 통해 비동기 처리를 구현합니다.

---

### 📌 12. HTTP 상태 코드 중 자주 사용하는 것?

> - **200 OK**: 정상 처리
>     
> - **201 Created**: 리소스 생성 완료
>     
> - **400 Bad Request**: 잘못된 요청
>     
> - **401 Unauthorized / 403 Forbidden**: 인증/권한 문제
>     
> - **404 Not Found**: 리소스 없음
>     
> - **500 Internal Server Error**: 서버 오류
>     
> 
> 프로젝트에서는 에러 핸들링 시 이 코드들을 명확히 구분해 클라이언트에서 UX 개선에 활용했습니다.

---

### 📌 13. Time Complexity(시간 복잡도)란?

> 알고리즘이 실행되는 데 걸리는 **시간의 증가율**을 수학적으로 나타낸 것입니다. 예: `O(1)`, `O(log n)`, `O(n)`, `O(n²)` 등.  
> 코드 작성 시 반복문, 재귀, 정렬 등에 대해 항상 시간 복잡도를 고려하고 있습니다.

---

### 📌 14. CORS란 무엇인가요?

> CORS(Cross-Origin Resource Sharing)는 **다른 출처 간 요청을 제한**하는 브라우저의 보안 정책입니다.  
> 서버에서 `Access-Control-Allow-Origin` 헤더를 설정하면 허용된 도메인에서만 요청을 보낼 수 있습니다. NestJS/Express에서는 `cors` 옵션으로 설정 가능합니다.

---

### 📌 15. Garbage Collection(가비지 컬렉션)이란?

> 프로그램 실행 중 더 이상 참조되지 않는 객체를 자동으로 메모리에서 제거해주는 메커니즘입니다. JavaScript, Python, Java 등 대부분의 언어에 내장되어 있으며, 개발자는 메모리 관리에 집중하지 않아도 됩니다. 다만, **순환 참조**나 **메모리 누수** 문제는 직접 관리가 필요할 수 있습니다.

---

## ✅ 1. 백엔드 엔지니어 관점 예상 질문 + 모범 답변

---

### 📌 1. NestJS를 선택한 이유는 무엇인가요?

> NestJS는 Angular에서 영감을 받은 구조로, **모듈화, DI, 데코레이터 기반 개발**이 잘 갖춰져 있어 대규모 서비스에 적합하다고 판단했습니다. 또한 TypeScript 기반이라 정적 타입의 이점도 크고, 테스트 및 유지보수가 용이했습니다.

---

### 📌 2. MVC 패턴을 어떻게 NestJS에서 구현했나요?

> NestJS는 기본적으로 Controller-Service-Repository 구조로, Controller는 요청 처리, Service는 비즈니스 로직, Repository는 DB 접근으로 역할이 분리됩니다. 이 구조는 유지보수성과 테스트 용이성을 높이는데 도움이 되었습니다.

---

### 📌 3. API 설계 시 어떤 기준으로 URI를 구성했나요?

> RESTful 규칙을 따르되, **자원 중심 설계**에 집중했습니다. 예를 들어 `/users/:id/plans`처럼 명확한 계층 구조를 따르고, 동사 대신 명사 사용을 지키려 했습니다. 또한 URI 버전 관리(`/api/v1/`)도 고려했습니다.

---

### 📌 4. 인증과 권한 관리를 어떻게 구현했나요?

> JWT 기반 인증을 사용했습니다. 로그인 시 토큰을 발급하고, 요청 시 Header의 토큰을 검증해 사용자 정보를 추출했습니다. 민감한 API는 Guard를 통해 권한별 접근 제어를 적용했고, 토큰 만료 및 재발급 로직도 구현했습니다.

---

### 📌 5. 트래픽이 많아질 경우 백엔드에서 어떤 대응을 하시겠습니까?

> 우선 **DB 쿼리 최적화와 캐싱(Redis)** 을 통해 응답 속도를 개선하고, **로드 밸런싱과 수평 확장**을 고려하겠습니다. 또한 API별 요청 수 제한(Rate Limiting)과 로그 기반 모니터링도 병행해 이상 탐지를 빠르게 하겠습니다.

---

### 📌 6. 서비스의 장애가 발생했을 때 대응 경험이 있나요?

> Tripwith 프로젝트 중 DB 연결 설정 누락으로 EC2에서 배포된 서버가 작동하지 않았던 경험이 있습니다. 로그를 기반으로 문제를 파악하고 환경변수 설정을 점검해 해결했으며, 이후 `health-check API`와 모니터링 도구를 추가했습니다.

---

### 📌 7. 에러 핸들링을 어떻게 설계하셨나요?

> NestJS에서는 `ExceptionFilter`를 통해 에러를 전역 처리했고, 사용자에게는 의미 있는 상태 코드와 메시지를 제공했습니다. 내부적으로는 로그를 남기고, 예외 발생 원인을 빠르게 파악할 수 있도록 구조화했습니다.

---

### 📌 8. DB 트랜잭션이 필요한 시나리오는 어떤 게 있을까요?

> 예를 들어 여행 플래너 등록 시, 장소 정보와 사용자 플래너 간의 연결 정보를 여러 테이블에 동시에 INSERT해야 하는데, 이때 트랜잭션을 사용하지 않으면 중간에 오류가 날 경우 데이터 정합성이 깨질 수 있습니다.

---

### 📌 9. Docker로 로컬 환경을 구성할 때 어려웠던 점은?

> 컨테이너 간 네트워크 연결 설정과, 컨테이너 내 경로/볼륨이 로컬과 일치하지 않아 데이터가 유실되거나 안 보이는 문제가 있었습니다. `docker-compose.yml` 설정과 `.env` 분리를 통해 문제를 해결했고, 개발과 배포 환경을 통일했습니다.

---

### 📌 10. CI/CD 파이프라인 구축 경험이 있나요?

> 개인 프로젝트에서는 GitHub Actions를 사용해 간단한 CI/CD를 구성해 봤습니다. 코드 Push 시 Lint 검사 및 테스트, Docker 이미지 빌드, EC2에 배포하는 스크립트를 작성했고, 자동화의 중요성을 체감할 수 있었습니다.

---

## ✅ 2. 머신러닝 엔지니어 관점 예상 질문 + 모범 답변

---

### 📌 1. LSTM + Attention 구조를 선택한 이유는?

> LSTM은 시계열 데이터에서 장기 의존성 학습에 유리하지만, 시점별 중요도를 구분하기 어렵습니다. Attention은 과거 입력 중 어떤 시점이 중요한지 가중치를 줄 수 있어 예측력 향상에 도움이 되었고, 모델 해석력도 높일 수 있었습니다.

---

### 📌 2. 시계열 예측 시 어떤 전처리를 진행했나요?

> 기후/경제 지표의 결측치는 평균 보간 또는 이전 값 보간으로 처리했고, 이상치는 IQR 방식으로 제거했습니다. 또한 각 변수의 단위를 맞추기 위해 MinMax Scaling을 사용해 학습 안정성을 확보했습니다.

---

### 📌 3. 감성 분석 모델에서 학습 데이터를 어떻게 구성하셨나요?

> 뉴스 기사 본문과 제목 데이터를 크롤링한 후, 한 문단 단위로 나누어 KoNLPy를 사용해 토큰화하고, 라벨링은 수동 검수된 일부 데이터를 기반으로 준지도 학습을 했습니다. BERT 기반 모델도 실험했습니다.

---

### 📌 4. MLOps에 대한 이해나 경험이 있으신가요?

> FastAPI를 통해 PyTorch 모델을 API 형태로 서빙해본 경험이 있습니다. 모델 로딩, 입력 검증, 예측 응답 처리까지 흐름을 구성했고, 향후에는 모델 버전 관리나 배치 추론 파이프라인도 구축해보고 싶습니다.

---

### 📌 5. 추천 시스템에서 벡터 기반 접근을 선택한 이유는?

> 사용자 선호 키워드와 콘텐츠 설명을 임베딩한 후, 코사인 유사도를 통해 유사도를 계산하면 **콘텐츠 간 의미 기반 거리 계산**이 가능해집니다. 키워드 매칭보다 유연하고 사용자 맞춤성이 높은 결과를 도출할 수 있습니다.

---

### 📌 6. 모델 성능 평가 지표는 어떤 것을 사용하셨나요?

> 시계열 예측 모델에서는 **RMSE**와 **MAPE**를 사용했습니다. 감성 분석에서는 **F1-score**를 기준으로 삼았고, 추천 시스템에서는 사용자 만족도 조사와 클릭 로그를 통해 A/B 테스트 방식으로 평가하려 했습니다.

---

### 📌 7. 머신러닝 프로젝트에서 가장 어려웠던 점은?

> 원두 가격 예측에서 **예측 신뢰도 부족**이 가장 큰 문제였습니다. 데이터의 시차 영향이 명확하지 않아 장기 예측이 어렵고, 감성 분석이 대부분 중립으로 분류돼 활용도가 낮았습니다. 이에 모델 구조와 활용 방식 자체를 변경했습니다.

---

### 📌 8. 과적합 문제를 어떻게 해결하셨나요?

> 모델 학습 시 **Dropout**, **조기 종료(Early Stopping)**, **정규화** 기법을 활용했습니다. 또한 학습/검증/테스트 셋을 철저히 분리하고, 모델 복잡도보다는 데이터 해석력 중심으로 설계했습니다.

---

### 📌 9. 하이퍼파라미터 튜닝을 어떻게 했나요?

> Grid Search보다는 시간이 덜 드는 Random Search 방식으로 주요 파라미터(LSTM unit 수, learning rate, window size 등)를 튜닝했습니다. 시각화를 통해 학습 곡선을 보며 성능 변화도 점검했습니다.

---

### 📌 10. 실제 배포 환경에서 ML 모델을 운영한다고 할 때 고려할 점은?

> 모델 응답 속도, 추론 안정성, 버전 관리가 중요합니다. 또한 입력 데이터의 이상 여부를 판단하는 로직도 필요하고, 일정 기간 후 **재학습 주기**나 **모델 성능 저하 감지 체계**도 마련해야 운영이 가능하다고 생각합니다.
