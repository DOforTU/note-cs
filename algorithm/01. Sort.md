# 01. Sort

> [[06. Sort]]
> - [자료구조/06. Sort](https://github.com/DOforTU/note-cs/blob/main/data%20structure/06.%20Sort.md) 참고


## 1.1 계수 정렬 (Counting Sort)

계수 정렬은 **정수 형태의 데이터를 빠르게 정렬하는 알고리즘**이다. 데이터의 크기를 기준으로 **개수를 세는 방식**으로 작동하며, 비교 기반 정렬이 아니다. 주어진 데이터가 **정수이고, 값의 범위가 제한적일 때** 매우 빠르게 동작한다.

동작 과정은 다음과 같다:

1. 데이터의 최댓값을 기준으로 크기 $k$짜리 **카운트 배열**을 만든다.
    
2. 원래 배열의 각 값을 카운트 배열의 해당 인덱스에 1씩 더해준다.
    
3. 카운트 배열을 순회하면서, 원래 데이터를 정렬된 순서로 복원한다.
    

예를 들어 `[3, 1, 2, 3, 1]`이 있다면, 크기 4짜리 카운트 배열 `[0, 2, 1, 2]`를 만든 후 이를 바탕으로 `[1, 1, 2, 3, 3]`으로 정렬할 수 있다.

시간 복잡도는 다음과 같다:

- 시간 복잡도: $O(n + k)$ (n은 데이터 수, k는 최댓값)
    
- 공간 복잡도: $O(k)$
    

장점:

- 비교 연산이 없기 때문에 이론적으로 매우 빠르다.
    
- 데이터의 분포가 균일하고 범위가 작을수록 성능이 좋다.
    

단점:

- 정수형 데이터만 사용할 수 있다.
    
- 값의 범위가 크면 메모리를 많이 사용하게 된다.
    
- 안정 정렬이 아니다. 같은 값의 순서가 바뀔 수 있다 (단, 안정화 처리를 따로 해주면 가능하다).
    

계수 정렬은 학생들의 점수(0~100)처럼 값의 범위가 정해져 있는 정수형 데이터에서 매우 유용하게 사용된다.

## 1.2 기수 정렬 (Radix Sort)

기수 정렬은 **자릿수를 기준으로 데이터를 정렬하는 알고리즘**이다. 각 숫자를 **맨 뒷자리부터 앞자리까지 순서대로 정렬**하면서 전체 데이터를 정렬해 나간다. 이때 각 자릿수 정렬에는 **안정 정렬(stable sort)**이 필요하다. 보통 Counting Sort를 사용한다.

동작 과정은 다음과 같다:

1. 가장 낮은 자릿수(1의 자리)부터 시작하여 해당 자릿수를 기준으로 정렬한다.
    
2. 그다음 자릿수(10의 자리), 그다음 자릿수(100의 자리) 순으로 정렬한다.
    
3. 가장 높은 자릿수까지 반복하여 전체 정렬을 완성한다.
    

예를 들어 `[170, 45, 75, 90, 802, 24, 2, 66]`이라는 숫자 배열이 있다면, 각 자리별로 정렬을 3번 수행해 최종 정렬된 결과를 얻는다.

시간 복잡도는 다음과 같다:

- 시간 복잡도: $O(d \cdot (n + k))$
    
    - $d$: 자릿수
        
    - $n$: 데이터 수
        
    - $k$: 자릿수 값의 범위 (예: 0~9면 10)
        
- 공간 복잡도: $O(n + k)$
    

장점:

- 정수, 문자열 등의 **고정된 길이의 키 값**을 정렬할 때 매우 빠르다.
    
- 비교 연산을 사용하지 않으며, 안정 정렬을 구현할 수 있다.
    

단점:

- 자릿수를 기준으로 하므로, **고정된 길이의 데이터**여야 한다.
    
- 자릿수가 많거나 값이 매우 클 경우, 속도와 공간 효율이 떨어질 수 있다.
    
- 기본적으로는 정수형 데이터만 다룬다.
    

기수 정렬은 전화번호, 주민번호, 우편번호 등 **형식이 정해진 숫자 데이터를 빠르게 정렬할 때** 효과적이다.