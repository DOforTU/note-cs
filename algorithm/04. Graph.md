# 04. Graph

## 4.1 탐색

### [BFS, DFS : 자료구조 참고](https://github.com/DOforTU/note-cs/blob/main/data%20structure/07.%20Graph%20BFS-DFS.md)

## 4.2 최소신장트리

**최소신장트리(MST, Minimum Spanning Tree)** 는 그래프 내 모든 정점을 연결하면서, **전체 간선 가중치의 합이 최소가 되는 트리**를 말한다.  
**무방향 가중치 그래프**에서 정의되며, 트리이기 때문에 **사이클이 없어야** 하고 **모든 정점을 연결**해야 한다.

MST의 핵심 조건:

- 모든 정점이 연결되어야 한다 (연결 그래프)
    
- 사이클이 없어야 한다
    
- 간선의 가중치 총합이 최소여야 한다
    

### 4.2.1 Prim 알고리즘

Prim 알고리즘은 **하나의 정점에서 시작해서 점차 트리를 확장**해나가는 방식이다. 항상 현재 트리에 인접한 **가장 작은 비용의 간선**을 선택하여 트리에 포함시킨다.

동작 방식:

1. 임의의 시작 정점을 선택한다.
    
2. 현재 선택된 정점들과 인접한 간선 중에서 가장 비용이 낮은 간선을 선택한다.
    
3. 해당 간선의 끝 정점을 트리에 포함시키고, 이 과정을 반복한다.
    

시간 복잡도:

- 우선순위 큐 + 인접 리스트 사용 시 $O(E \log V)$
    

특징:

- Dense graph(간선이 많은 그래프)에 더 적합하다.
    
- 구현 시 **우선순위 큐(Heap)**를 사용하면 효율적이다.
    

### 4.2.2 Kruskal 알고리즘

Kruskal 알고리즘은 **모든 간선을 가중치 기준으로 정렬한 뒤**, 사이클을 만들지 않도록 간선을 하나씩 선택해 나가는 방식이다.

동작 방식:

1. 모든 간선을 가중치 기준으로 오름차순 정렬한다.
    
2. 가장 짧은 간선부터 하나씩 선택하면서, **사이클이 생기지 않으면** 해당 간선을 MST에 포함시킨다.
    
3. 이 과정을 간선 수가 $V - 1$개가 될 때까지 반복한다.
    

사이클 여부는 **Union-Find(Disjoint Set)** 자료구조로 판단한다.

시간 복잡도:

- $O(E \log E)$ (간선 정렬 포함)
    

특징:

- Sparse graph(간선이 적은 그래프)에 적합하다.
    
- 구현이 간단하고, 간선 중심으로 동작한다.
    

## 4.3 위상정렬

위상정렬(Topological Sort)은 **방향 그래프(DAG)에서 정점들을 선형으로 나열하는 정렬 방법**이다.  
모든 간선 $(u \rightarrow v)$에 대해 정렬된 순서에서 $u$가 $v$보다 앞에 오도록 하는 정점의 나열이다.

조건:

- 사이클이 없는 **방향 그래프(DAG)** 여야 한다.
    
- 정렬 결과는 유일하지 않을 수 있다.
    

위상정렬은 주로 **작업 순서**, **의존 관계**, **빌드 순서** 등을 처리할 때 사용된다.

### 4.3.1 TopologicalSort 알고리즘

가장 널리 쓰이는 방법은 **진입 차수(in-degree)** 를 이용하는 알고리즘이다.

동작 방식:

1. 각 정점의 진입 차수를 계산한다.
    
2. 진입 차수가 0인 정점을 큐에 넣는다.
    
3. 큐에서 하나씩 꺼내며 결과에 추가하고, 해당 정점과 연결된 간선들을 제거한다.
    
4. 연결된 정점의 진입 차수가 0이 되면 큐에 추가한다.
    
5. 큐가 빌 때까지 반복한다.
    

시간 복잡도:

- $O(V + E)$
    

특징:

- 사이클이 있는 경우 정렬이 불가능하다.
    
- 여러 개의 결과가 나올 수 있다 (진입 차수 0인 정점이 여러 개일 경우)
    
## 4.4 최단경로

최단경로 알고리즘은 **그래프에서 두 정점 사이의 가장 짧은 거리(가중치 합)를 찾는 알고리즘**이다.  
문제 유형에 따라 단일 출발점, 단일 도착점, 모든 정점 쌍 간 최단경로 등이 있다.

### 4.4.1 Floyd-Warshall 알고리즘

Floyd-Warshall 알고리즘은 **모든 정점 쌍 사이의 최단 경로를 구하는 알고리즘**이다.  
**동적 계획법(DP)** 을 이용하며, 간선 가중치가 음수일 수 있지만 **음수 사이클은 없어야** 한다.

동작 방식:

- 3중 반복문을 통해, 각 정점 $k$를 거쳐 가는 경로가 더 짧은지를 확인한다.
    
- 점화식:
    
    $D[i][j]=min⁡(D[i][j],  D[i][k]+D[k][j])$

시간 복잡도:

- $O(V^3)$
    

특징:

- 간단하지만 느리기 때문에 정점 수가 적을 때 적합하다.
    
- 인접 행렬을 사용하는 그래프에서 잘 동작한다.
    
- 간선 수와 상관없이 정점 수에만 영향을 받는다.
    


## 4.5 싸이클이 없는 그래프(DAG)에서의 최단 경로

싸이클이 없는 방향 그래프(DAG)는 **특별한 성질**을 가지고 있어, 최단 경로 문제를 더 효율적으로 풀 수 있다.  
특히 DAG에서는 **위상 정렬을 이용하면 음수 가중치가 있어도** 빠르게 최단 경로를 구할 수 있다.

최단 경로 알고리즘에는 대표적으로 다음 세 가지가 있다.

### 4.5.1 Dijkstra 알고리즘

Dijkstra 알고리즘은 **음수 가중치가 없는 그래프**에서 **단일 출발점 최단 경로**를 구하는 알고리즘이다.  
가장 가까운 정점부터 탐색하며 최단 거리를 갱신해 나간다.

동작 방식:

1. 출발 노드의 거리는 0, 나머지는 무한대로 초기화한다.
    
2. **우선순위 큐(Heap)** 를 사용해 가장 거리가 짧은 정점을 선택한다.
    
3. 해당 정점과 연결된 이웃 노드의 거리를 갱신한다.
    
4. 모든 노드를 처리할 때까지 반복한다.
    

시간 복잡도:

- 인접 리스트 + 우선순위 큐 사용 시 $O(E \log V)$
    

특징:

- 음수 가중치가 있으면 사용할 수 없다.
    

### 4.5.2 Bellman-Ford 알고리즘

Bellman-Ford 알고리즘은 **음수 가중치가 있는 그래프에서도 사용 가능한 단일 출발점 최단 경로 알고리즘**이다.  
**모든 간선을 반복적으로 검사하며** 최단 경로를 갱신한다.

동작 방식:

1. 출발 노드를 0, 나머지를 무한대로 초기화한다.
    
2. 모든 간선을 최대 $V - 1$번 반복하여 갱신한다.
    
3. 이후 한 번 더 반복하여 **음수 사이클**이 있는지 확인한다.
    

시간 복잡도:

- $O(V \cdot E)$
    

특징:

- 음수 가중치를 허용하며, **음수 사이클 존재 여부도 확인 가능**하다.
    
- Dijkstra보다 느리지만 범용성이 높다.
    

### 4.5.3 위상정렬을 이용한 알고리즘

DAG에서의 최단 경로 문제는 **위상 정렬을 기반으로 해결할 수 있는 효율적인 방법**이 있다.  
정점들의 정렬 순서를 따르면서 거리를 갱신해 나가면 된다.

동작 방식:

1. 모든 노드를 위상 정렬한다.
    
2. 출발 노드의 거리는 0으로 두고, 나머지는 무한대로 설정한다.
    
3. 위상 정렬 순서대로 각 노드를 탐색하면서, 인접 노드의 거리를 갱신한다.
    

시간 복잡도:

- $O(V + E)$ (위상 정렬과 동일)
    

특징:

- DAG에서만 사용 가능하다.
    
- 음수 가중치도 처리 가능하다.
    
- 매우 빠르며, 구현도 간단하다.
    

## 4.6강연결요소

강연결요소(Strongly Connected Component, SCC)는 **방향 그래프에서 모든 정점 쌍이 서로 도달 가능한 부분 그래프**를 의미한다.  
즉, 어떤 정점 A에서 B로 갈 수 있고, B에서도 A로 갈 수 있다면 둘은 같은 강연결요소에 속한다.

SCC는 **그래프를 구성하는 최소 단위의 닫힌 부분 그래프**라고 볼 수 있으며, 복잡한 그래프를 요약할 때 매우 유용하다.

### 4.6.1 StronglyConnectedComponent 알고리즘

SCC를 찾는 대표적인 알고리즘은 **Kosaraju 알고리즘**이다. 두 번의 DFS로 전체 그래프의 강연결요소를 찾는다.

동작 방식:

1. 원래 그래프에서 **DFS 후, 노드의 종료 순서를 스택에 저장**한다.
    
2. **모든 간선의 방향을 뒤집은 그래프**를 만든다.
    
3. 스택에서 하나씩 꺼내며 DFS를 다시 수행하면, 그 탐색 경로가 하나의 SCC가 된다.
    

시간 복잡도:

- $O(V + E)$
    

특징:

- 간단하고 효율적인 알고리즘이다.
    
- 방향 그래프의 구조를 분해하거나 분석할 때 자주 사용된다.
    

다른 방법으로는 **Tarjan 알고리즘**도 있으며, 하나의 DFS로 SCC를 찾을 수 있다.
