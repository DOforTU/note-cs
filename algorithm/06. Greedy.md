# 06. Greedy

## 6.1 Greedy (그리디 알고리즘)

그리디(Greedy) 알고리즘은 문제를 해결할 때 **현재 상황에서 가장 좋아 보이는 선택만을 반복하여 최적의 해를 구하는 방식**이다. 매 단계에서의 "최적 선택"이 전체적으로도 최적이라는 보장이 있을 때 유효하게 동작한다.

기본 특징:

- **탐욕적 선택 속성(Greedy Choice Property)**:  
    전체 문제에 대한 최적해가 **각 단계의 지역적 최적 선택**으로 구성될 수 있어야 한다.
    
- **최적 부분 구조(Optimal Substructure)**:  
    부분 문제의 최적해가 전체 문제의 최적해로 이어져야 한다.
    

그리디 알고리즘은 동적 계획법과 비교해 구현이 간단하고 빠르지만, 항상 정답을 보장하지는 않는다. 따라서 **그리디 방법이 유효한지를 분석하거나 증명**하는 과정이 필요하다.

예시 문제:

- 동전 거스름돈 문제 (동전의 단위가 일정한 경우)
    
- 회의실 배정 문제
    
- 최소 신장 트리 (Prim, Kruskal)
    
- 활동 선택 문제, 작업 스케줄링 등
    

시간 복잡도는 일반적으로 $O(n \log n)$ 또는 $O(n)$ 수준으로 빠른 경우가 많다. 다만, 정렬이 필요한 경우 $O(n \log n)$이 된다.

## 6.2 회의실 배정

회의실 배정 문제는 그리디 알고리즘의 대표적인 예시이다. 문제는 다음과 같다:

- 여러 개의 회의가 있고, 각 회의는 시작 시간과 종료 시간이 있다.
    
- 하나의 회의실에서 **겹치지 않게 가장 많은 회의를 배정**하는 것이 목표이다.
    

핵심 아이디어:

- **종료 시간이 빠른 회의부터 선택**하면 이후 회의 배정 기회를 극대화할 수 있다.
    
- 회의의 시작 시간을 기준으로 하면 정답이 안 나올 수 있으므로, 종료 시간을 기준으로 정렬한다.
    

알고리즘:

1. 회의를 종료 시간을 기준으로 오름차순 정렬한다.
    
2. 가장 먼저 끝나는 회의를 선택하고, 그 이후 **시작 시간이 이전 회의 종료 시간 이상인** 회의만 선택한다.
    
3. 이 과정을 반복하여 가능한 많은 회의를 선택한다.
    

시간 복잡도:

- 정렬: $O(n \log n)$
    
- 선택 과정: $O(n)$  
    → 전체 $O(n \log n)$
    

> [백준 - 1931번: 회의실 배정](https://www.acmicpc.net/problem/1931)

```python
# 문제
# 한 개의 회의실이 있는데 이를 사용하고자 하는 N개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 I에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.

# 입력
# 첫째 줄에 회의의 수 N(1 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N+1 줄까지 각 회의의 정보가 주어지는데 이것은 공백을 사이에 두고 회의의 시작시간과 끝나는 시간이 주어진다. 시작 시간과 끝나는 시간은 231-1보다 작거나 같은 자연수 또는 0이다.

# 출력
# 첫째 줄에 최대 사용할 수 있는 회의의 최대 개수를 출력한다.

n = int(input())
meetings = []
count = 0
last_meeting_end = 0

# 회의의 시작 시간과 끝나는 시간을 입력받아 meetings 리스트에 저장
for _ in range(n):
    start, end = map(int, input().split())
    meetings.append((start, end)) # 요소를 변경할 필요 없이 고정이므로 튜플로 저장

# 회의들을 끝나는 시간 기준으로 정렬
meetings.sort(key=lambda x: (x[1], x[0]))

# 그리디 알고리즘을 사용하여 회의의 최대 개수를 계산

for start, end in meetings:
    if start >= last_meeting_end:
        last_meeting_end = end
        count += 1
        # print(f"회의 시작: {start}, 끝나는 시간: {end}, 회의 개수: {count}")

print(count)
```

이 문제는 **활동 선택 문제(Activity Selection Problem)** 와 동일하며, 그리디 전략이 항상 최적해를 보장하는 대표적인 경우이다.

---

## 6.3 Huffman Code 알고리즘

Huffman 코딩 알고리즘은 **가장 효율적인 이진 문자 인코딩을 생성하는 알고리즘**이다.  
문자열을 압축하거나 통신에서 사용하는 **가변 길이 부호(variable-length code)** 를 만들 때 사용된다.

기본 아이디어:

- **자주 등장하는 문자는 짧은 코드**, 드물게 등장하는 문자는 **긴 코드**를 부여하여 전체 인코딩 길이를 줄인다.
    
- 문자 빈도수를 기준으로 **최소 힙(Min Heap)** 을 사용하여 **최적 이진 트리(Huffman Tree)** 를 만든다.
    

알고리즘:

1. 각 문자를 노드로 만들고 빈도를 저장한다.
    
2. 빈도 기준으로 가장 작은 두 노드를 꺼내 새 노드로 병합한다.
    
3. 이 과정을 하나의 트리만 남을 때까지 반복한다.
    
4. 루트부터 각 문자까지의 경로를 따라 0과 1을 부여한다.
    

예시:

- 입력 문자: A(5), B(9), C(12), D(13), E(16), F(45)
    
- 최종 Huffman 코드 예시:  
    A: 1100, B: 1101, C: 100, D: 101, E: 111, F: 0
    

시간 복잡도:

- $O(n \log n)$ (힙을 사용한 병합 과정 기준)
    

특징:

- 무손실 압축에 사용된다.
    
- 최적 부호화를 보장한다.
    
- 트리 기반이며, prefix-free(어떤 코드도 다른 코드의 접두어가 아님) 구조이다.
    

Huffman 알고리즘은 **파일 압축(zip, gzip 등)**, **네트워크 통신**, **멀티미디어 인코딩(MPEG, MP3)** 등 실제 응용이 매우 넓다.