# Selection

## 2.1 퀵 정렬 방식을 이용한 선택 알고리즘

퀵 정렬 방식을 이용한 선택 알고리즘은, 정렬하지 않고도 **배열에서 k번째로 작은 값(또는 큰 값)** 을 찾을 수 있는 방법이다. 이를 **Quickselect**라고 부르며, 퀵 정렬의 분할(Partition) 아이디어를 그대로 활용한다.

동작 방식은 다음과 같다:

1. 임의의 **pivot** 값을 고른다.
    
2. pivot을 기준으로 배열을 두 부분으로 나눈다.
    
    - 왼쪽: pivot보다 작은 값들
        
    - 오른쪽: pivot보다 큰 값들
        
3. 만약 pivot이 배열에서 정확히 k번째 값이면 그 값을 반환한다.
    
4. 아니라면 k의 위치에 따라 왼쪽 또는 오른쪽 부분배열에서 다시 같은 과정을 반복한다.
    

예를 들어 `[7, 2, 1, 6, 8, 5, 3, 4]` 배열에서 3번째로 작은 값을 찾고 싶다면, pivot을 기준으로 나누고 그 위치를 기준으로 왼쪽 또는 오른쪽에서 탐색을 계속하면 된다.

시간 복잡도는 다음과 같다:

- 평균: $O(n)$ (퀵 정렬과 달리 정렬을 끝까지 하지 않기 때문)
    
- 최악: $O(n^2)$ (pivot이 계속 최악의 위치로 선택될 경우)
    

장점:

- 정렬하지 않고 원하는 순위의 값만 찾기 때문에 전체 정렬보다 빠르다.
    
- 구현이 간단하며, 실용적 상황에서 매우 빠르게 동작한다.
    

단점:

- pivot 선택이 나쁘면 성능이 매우 나빠질 수 있다.
    
- 최악의 경우가 $O(n^2)$이기 때문에 안정성이 떨어진다.
    

## 2.2 중앙값의 중앙값을 이용한 선택 알고리즘

중앙값의 중앙값 알고리즘은 퀵 정렬 방식 선택 알고리즘의 **최악의 시간 복잡도 문제를 해결하기 위한 개선된 방식**이다. 이 방법은 항상 **좋은 pivot**을 선택하기 위한 전략으로, 최악의 경우에도 $O(n)$ 시간에 k번째 값을 찾을 수 있도록 보장한다.

기본 아이디어는 다음과 같다:

1. 배열을 5개씩 그룹으로 나눈다. (그룹 수가 5개 이하일 경우 그냥 진행)
    
2. 각 그룹의 **중앙값**을 구한다.
    
3. 이 중앙값들로 이루어진 배열에서 다시 중앙값을 구한다.
    
    - 이 값을 **pivot**으로 사용한다. → 이것이 "중앙값의 중앙값(median of medians)"이다.
        
4. 이 pivot을 기준으로 배열을 나누고, Quickselect 방식과 동일하게 진행한다.
    

이 방식은 pivot을 **무작위로 고르지 않고, 항상 좋은 분할이 일어나도록 보장**한다. 이 때문에, 최악의 경우에도 전체 데이터를 반복적으로 반씩 줄일 수 있다.

시간 복잡도는 다음과 같다:

- 최악의 경우에도 $O(n)$
    
- 추가적인 그룹화 및 중앙값 계산 비용이 들지만, 큰 데이터에서도 안정적으로 동작한다
    

장점:

- 최악의 경우에도 $O(n)$을 보장하는 **이론적으로 매우 강력한 알고리즘**이다.
    
- pivot 선택이 항상 균형 잡혀 있기 때문에 성능이 예측 가능하다.
    

단점:

- 구현이 복잡하다.
    
- 평균적인 경우에는 Quickselect보다 느릴 수 있다.
    
- 실제로는 일반 Quickselect가 더 빠르게 작동하는 경우가 많다.
    