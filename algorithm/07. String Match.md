# 07. String Match

## 7.1 원시매칭

원시매칭(Naive Matching)은 문자열 검색에서 가장 단순한 알고리즘이다. 텍스트 문자열 $T$와 패턴 문자열 $P$가 주어졌을 때, $T$ 안에서 $P$와 일치하는 부분을 하나씩 비교하여 찾는다.

동작 방식:

1. 텍스트의 첫 위치부터 시작하여, 패턴의 모든 문자와 일치하는지 순서대로 비교한다.
    
2. 일치하지 않으면 텍스트에서 한 글자 오른쪽으로 이동해서 다시 비교한다.
    
3. 이를 텍스트의 끝까지 반복한다.
    

예시:

- $T = \text{"ABC ABCDAB ABCDABCDABDE"}$
    
- $P = \text{"ABCDABD"}$
    

시간 복잡도:

- 최악: $O(nm)$ ($n$: 텍스트 길이, $m$: 패턴 길이)
    

장점:

- 이해와 구현이 매우 쉽다.
    

단점:

- 반복적으로 같은 위치를 다시 비교하기 때문에 비효율적이다.
    
- 긴 문자열에서는 속도가 매우 느리다.
    

## 7.2 Automata

Automata(오토마타 기반 문자열 검색)는 **유한 상태 머신(Finite State Machine)** 을 사용하여 문자열을 인식하는 방식이다. 입력 문자열을 문자 하나씩 읽으며 상태를 전이하고, **패턴이 완전히 인식되면 매칭 성공**으로 처리한다.

핵심 개념:

- 각 상태는 패턴 문자열의 일부분과 일치한 정도를 나타낸다.
    
- 상태 전이 테이블(Transition Table)을 미리 계산해 놓는다.
    
- 입력을 따라가면서 테이블을 참조해 상태를 이동한다.
    

동작 방식:

1. 패턴 문자열로부터 상태 전이 테이블을 생성한다.
    
2. 입력 문자열을 한 글자씩 읽으며, 현재 상태와 입력에 따라 다음 상태로 전이한다.
    
3. 최종 상태에 도달하면 패턴 매칭이 완료된다.
    

시간 복잡도:

- 전이 테이블 생성: $O(m|\Sigma|)$ ($m$: 패턴 길이, $\Sigma$: 알파벳 집합)
    
- 문자열 검색: $O(n)$
    

장점:

- 문자열을 한 번만 훑으며 검색할 수 있다.
    
- 전이 테이블만 있으면 매우 빠르게 처리된다.
    

단점:

- 상태 전이 테이블을 만드는 데 시간이 걸리고 메모리를 많이 쓸 수 있다.
    
- 복잡한 구현이 필요하다.
    

## 7.3 KMP

KMP(Knuth-Morris-Pratt) 알고리즘은 **패턴 내부의 구조를 이용해 중복 비교를 줄이는 문자열 검색 알고리즘**이다.  
불일치가 발생했을 때, **패턴 내에서 다음 어디서부터 비교를 재개할지 미리 계산해두는 방식**을 사용한다.

핵심 개념:

- **접두사(prefix)** 와 **접미사(suffix)** 의 일치 정보를 기반으로,  
    패턴의 실패 테이블(= lps 배열 또는 pi 배열)을 생성한다.
    

동작 방식:

1. **사전 처리 단계**: 패턴 문자열에서 접두사와 접미사의 일치 정보를 이용해 $lps$ 배열 생성  
    ($lps[i]$는 $P[0:i]$의 접두사와 접미사가 일치하는 최대 길이)
    
2. **탐색 단계**: 텍스트에서 패턴을 비교하면서, 불일치 발생 시 $lps$ 배열을 참고하여 패턴을 다시 정렬한다.
    

시간 복잡도:

- 전처리: $O(m)$
    
- 검색: $O(n)$  
    → 전체: $O(n + m)$
    

장점:

- 문자열을 한 번만 순회하여 검색하므로 빠르다.
    
- 비교를 되돌아가지 않기 때문에 시간 낭비가 없다.
    

단점:

- lps 배열 구성 로직이 직관적이지 않아 처음 이해하기 어렵다.
    

KMP는 실전 문제 풀이, 정규식 구현, 텍스트 에디터 검색 기능 등에서 널리 사용된다.

## 7.4 Rabin-Karp

Rabin-Karp 알고리즘은 문자열을 **해시 값으로 변환하여 비교하는 방식**을 사용한다.  
직접 문자열을 비교하지 않고, **패턴과 동일한 해시 값을 가진 구간이 있는지 빠르게 탐색**한다.

핵심 아이디어:

- 슬라이딩 윈도우 방식으로 텍스트의 각 구간을 해시로 변환한다.
    
- 패턴의 해시와 일치하는 구간이 있으면, 실제 문자열을 다시 비교해 확인한다.
    

동작 방식:

1. 패턴 문자열의 해시값 $H_P$를 계산한다.
    
2. 텍스트 문자열의 길이 $m$인 모든 구간의 해시값을 계산한다.
    
3. 각 구간 해시값이 $H_P$와 일치하면, 실제 문자열을 확인해 매칭 여부를 판별한다.
    

해시 함수 예시:

- $H(S) = (S[0] \cdot b^{m-1} + S[1] \cdot b^{m-2} + \dots + S[m-1]) \bmod q$
    

시간 복잡도:

- 평균: $O(n + m)$
    
- 최악: $O(nm)$ (해시 충돌이 모두 발생하는 경우)
    

장점:

- 여러 개의 패턴을 동시에 검색할 때 효율적이다.
    
- 해시 기반이므로 비교 횟수를 줄일 수 있다.
    

단점:

- **해시 충돌**이 일어나면 성능이 떨어진다.
    
- 큰 수의 연산을 다루기 때문에 모듈러 연산, 롤링 해시 등이 필요하다.
    

Rabin-Karp는 바이러스 탐지, 문서 표절 검사, 대용량 텍스트 처리 등에서 사용된다.