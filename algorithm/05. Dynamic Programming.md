# 05. Dynamic Programming

## 5.1 Dynamic Programming

Dynamic Programming(DP, 동적 계획법)은 **복잡한 문제를 작은 하위 문제로 나누어 해결하고**, 그 결과를 저장하여 **중복 계산을 피하는 알고리즘 설계 기법**이다.  
보통 **최적화 문제**에서 사용되며, **이전에 계산한 값을 재사용**하여 효율을 높인다.

DP가 사용되기 위한 조건은 두 가지이다:

1. **겹치는 부분 문제(Overlapping Subproblems)**:  
    동일한 작은 문제가 여러 번 반복해서 등장해야 한다.
    
2. **최적 부분 구조(Optimal Substructure)**:  
    문제의 최적 해가 **하위 문제의 최적 해로 구성**될 수 있어야 한다.
    

DP는 일반적으로 다음과 같은 두 가지 방식으로 구현한다:

- **Top-down (재귀 + 메모이제이션)**  
    큰 문제를 해결하려고 할 때, 작은 문제를 재귀 호출하고 그 결과를 캐시에 저장한다.
    
- **Bottom-up (반복문 + 테이블)**  
    가장 작은 문제부터 차례로 해결해가며 테이블에 결과를 저장한다.
    

예시: 피보나치 수열

- 일반 재귀는 $O(2^n)$이지만
    
- DP를 사용하면 $O(n)$으로 줄일 수 있다.
    

DP의 핵심은 **중간 결과를 저장하는 배열(table)** 을 정의하고,  
**점화식(recurrence relation)** 을 세우는 것이다.

예를 들어,

$$DP[i]=min⁡(DP[i−1],  DP[i−2])+cost[i]$$

DP는 다음과 같은 문제 유형에서 자주 등장한다:

- 최단 경로
    
- 배낭 문제(Knapsack)
    
- 문자열 비교
    
- 게임 이론
    
- 계단 오르기, 점프 문제 등
    

## 5.2 최장 공통 부분 순서(LCS) 알고리즘

LCS(Longest Common Subsequence)는 **두 문자열에서 순서를 유지하면서 공통적으로 등장하는 가장 긴 부분 수열을 찾는 문제**이다.  
부분 수열은 반드시 연속될 필요는 없지만, 순서는 유지되어야 한다.

예시:  
문자열 $A = \text{ACDBE}$, $B = \text{ABCDE}$일 때, LCS는 `ACDE`가 아니라 `ADE` 또는 `ACE` 등이 될 수 있다.

LCS는 **Dynamic Programming을 사용해서 효율적으로 해결**할 수 있다.

동작 방식:

1. 문자열 A의 길이 $n$, B의 길이 $m$일 때, 크기 $(n+1) \times (m+1)$인 DP 테이블을 만든다.
    
2. $DP[i][j]$는 A의 $i$번째 문자까지와 B의 $j$번째 문자까지의 LCS 길이를 저장한다.
    

점화식은 다음과 같다:

- 두 문자가 같을 때:  
    $DP[i][j] = DP[i - 1][j - 1] + 1$ (if $A[i - 1] = B[j - 1]$)
    
- 두 문자가 다를 때:  
    $DP[i][j] = \max(DP[i - 1][j],\; DP[i][j - 1])$ (otherwise)

이 과정을 통해 LCS의 길이를 구할 수 있으며, 경로를 추적하면 실제 공통 수열도 복원할 수 있다.

시간 복잡도:

- $O(n \cdot m)$ (문자열 길이에 비례)
    

특징:

- 부분 문자열이 아니라, **부분 수열**이라는 점이 핵심이다.
    
- 문자열 비교, 버전 차이 분석(diff), DNA 서열 분석 등에서 자주 쓰인다.
    

LCS는 문자열 관련 DP 문제의 대표적인 예시이며, 다른 유사한 문제들(편집 거리, 문자열 정렬 등)의 기초가 되는 알고리즘이다.