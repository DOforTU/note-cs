## 📁 1. 자료구조 (Data Structures)

### Q1. 배열과 연결 리스트의 차이점은?

**A.** 배열은 인덱스를 통해 빠르게 접근할 수 있어 조회 속도가 빠르지만, 크기가 고정되어 있어 삽입/삭제에 비효율적이다. 반면 연결 리스트는 동적 메모리 할당이 가능하고 삽입/삭제가 빠르지만, 인덱스로 접근이 불가능해 순차 탐색이 필요하다.

### Q2. 스택과 큐의 차이점은?

**A.** 스택은 후입선출(LIFO) 구조이고, 큐는 선입선출(FIFO) 구조이다. 스택은 함수 호출 스택, 괄호 검사 등에, 큐는 작업 순서 처리나 BFS에 자주 활용된다.

### Q3. 해시 테이블에서 충돌이 발생하면 어떻게 해결할 수 있는가?

**A.** 대표적인 충돌 해결 방법은 체이닝(Chaining)과 개방 주소법(Open Addressing)이 있다. 체이닝은 연결 리스트를 이용해 같은 해시 인덱스에 여러 값을 저장하고, 개방 주소법은 빈 슬롯을 찾아 이동하면서 저장한다.

---

## 📁 2. 알고리즘 (Algorithms)

### Q1. 퀵 정렬과 병합 정렬의 차이점은?

**A.**  
퀵 정렬은 분할 정복 알고리즘으로, 하나의 피벗 값을 기준으로 작은 값과 큰 값으로 나눠 재귀적으로 정렬한다. 평균 시간복잡도는 $O(n \log n)$이지만, 최악의 경우 $O(n^2)$까지 발생할 수 있다. 메모리를 추가로 사용하지 않는 **제자리 정렬**이며, 정렬 안정성은 없다.

반면 병합 정렬은 배열을 반으로 나눈 후 각각 정렬하고 다시 병합하는 **병합(merge)** 과정을 통해 정렬을 수행한다. 항상 $O(n \log n)$의 성능을 보장하고, 정렬 안정성이 있으며, 다만 배열 병합 과정에서 **추가 메모리 공간이 필요하다.**

> 퀵 정렬은 평균적으로 빠르지만 최악의 경우 느려지고, 병합 정렬은 항상 일정한 성능을 보장한다.  
> 퀵 정렬은 제자리 정렬이지만 안정 정렬이 아니고, 병합 정렬은 안정 정렬이지만 추가 메모리를 사용한다.  
> 병합 정렬은 큰 데이터 처리나 외부 정렬에 적합하며, 퀵 정렬은 메모리 제약이 있는 환경에 적합하다.

### Q2. 버블 정렬, 선택 정렬, 퀵 정렬, 병합 정렬, 힙 정렬의 개념과 차이를 설명해보세요.

**A.**  
버블 정렬은 인접한 원소를 비교해 큰 값을 뒤로 보내는 방식으로, 단순하지만 효율이 낮아 $O(n^2)$의 시간복잡도를 가진다.  
선택 정렬은 매 단계마다 최솟값을 선택해서 앞쪽과 교환하는 방식으로, 마찬가지로 $O(n^2)$의 시간이 걸리며 데이터의 상태에 관계없이 동일한 횟수의 비교가 발생한다.

퀵 정렬은 기준값(피벗)을 중심으로 데이터를 분할하여 재귀적으로 정렬하는 알고리즘으로, 평균 $O(n \log n)$의 빠른 성능을 보인다. 병합 정렬은 배열을 나누고 병합하면서 정렬하는 방식으로, 항상 $O(n \log n)$의 안정적인 성능을 제공하며 **안정 정렬**이다.

힙 정렬은 힙 자료구조를 사용해서 최대값 또는 최소값을 반복적으로 꺼내 정렬하는 방식이며, 시간복잡도는 $O(n \log n)$이고 **제자리 정렬이지만 안정 정렬은 아니다.**

> 버블/선택 정렬은 $O(n^2)$로 느리고, 주로 학습용이다.  
> 퀵 정렬은 빠르지만 피벗 선택이 나쁘면 느려질 수 있다.  
> 병합 정렬은 안정적이지만 메모리를 더 사용한다.  
> 힙 정렬은 메모리는 적게 쓰지만 정렬 결과의 순서 보장은 없다.

### Q3. DFS와 BFS의 차이점은?

**A.**  
DFS(Depth-First Search)는 깊이 우선 탐색으로, 한 경로를 가능한 끝까지 탐색한 뒤 다른 경로로 이동하는 방식이다. 일반적으로 **재귀 호출**이나 **스택**을 통해 구현되며, 백트래킹이나 사이클 탐지 등에 유용하다.

BFS(Breadth-First Search)는 너비 우선 탐색으로, 가까운 노드부터 차례로 탐색하며, **큐**를 사용해 구현한다. 모든 경로의 비용이 동일할 경우 최단 경로를 보장하기 때문에, 최단 거리 문제에 많이 사용된다.

> DFS는 깊게 파고드는 방식이고, BFS는 넓게 탐색하는 방식이다.  
> DFS는 재귀/스택, BFS는 큐를 사용한다.  
> BFS는 최단 거리 문제에 적합하고, DFS는 경로 탐색이나 조합 문제에 활용된다.

### Q4. 다익스트라 알고리즘과 벨만-포드 알고리즘의 차이점은?

**A.**  
다익스트라 알고리즘은 **가중치가 음수가 없는 그래프**에서 단일 출발지로부터 모든 정점까지의 최단 경로를 계산하는 알고리즘이다. 일반적으로 **우선순위 큐**를 사용하여 현재까지 거리 값이 가장 작은 정점을 먼저 탐색하고, 이미 방문한 노드는 다시 방문하지 않는다. 시간복잡도는 $O((V+E)\log V)$이다.

벨만-포드 알고리즘은 **음수 가중치 간선을 허용하며, 음수 사이클도 탐지할 수 있는 알고리즘**이다. 모든 간선을 최대 (V−1)번 반복하면서 최단 경로를 갱신하고, 마지막 반복에서도 값이 바뀌면 음수 사이클이 존재한다고 판단한다. 시간복잡도는 $O(VE)$로 느리지만, 더 일반적인 상황에 사용된다.

> 다익스트라는 빠르지만 음수 간선을 허용하지 않는다.  
> 벨만-포드는 느리지만 음수 간선과 음수 사이클까지 처리할 수 있다.  
> 두 알고리즘 모두 단일 시작점 기준의 최단 경로 문제를 해결한다.  
> 그래프의 특성에 따라 적절한 알고리즘을 선택해야 한다.

---

## 📁 3. 운영체제 (Operating Systems)

### Q1. 프로세스와 스레드의 차이는?

**A.** 프로세스는 독립된 메모리 공간을 가지는 실행 단위이고, 스레드는 프로세스 내에서 실행되는 작업 단위로 메모리를 공유한다. 스레드는 경량화된 처리에 적합하며, 자원 공유로 인해 동기화 문제가 발생할 수 있다.

### Q2. 데드락이란 무엇이며 이를 방지하는 방법은?

**A.** 데드락은 두 개 이상의 프로세스가 서로 자원을 점유한 상태에서 상대방의 자원을 기다리며 무한히 대기하는 상태이다. 방지 방법에는 자원 순서 지정, 타임아웃, 교착 상태 탐지 및 회복 등이 있다.

### Q3. 사용자가 브라우저에서 URL을 입력했을 때, 어떤 과정을 거쳐 서버와 통신하고 응답을 받는가?

사용자가 브라우저 주소창에 URL을 입력하면, 먼저 도메인 이름을 IP 주소로 바꾸기 위해 DNS 조회가 이루어진다. 이 과정을 통해 실제로 요청을 보낼 서버의 IP를 알게 된다.

그 다음에는 TCP 3-way 핸드셰이크 과정을 거쳐 서버와의 연결을 맺는다. 클라이언트가 SYN을 보내고, 서버는 SYN-ACK를 응답하며, 마지막으로 클라이언트가 ACK를 보내 연결이 확립된다.

연결이 완료되면 브라우저는 HTTP 요청을 전송한다. 이 요청에는 메서드(GET, POST 등)와 함께 헤더, 쿠키, 본문 등의 정보가 담긴다.

요청은 먼저 웹 서버(Nginx나 Apache 등)에 도달하고, 이후 내부의 웹 애플리케이션 서버, 즉 WAS로 전달된다. WAS에서는 라우팅, 비즈니스 로직, 인증, 데이터 가공 등의 처리가 이루어진다.

WAS가 데이터가 필요할 경우, 내부적으로 데이터베이스에 SQL 쿼리를 보내고, 결과를 받아온다. 받아온 데이터를 기반으로 JSON이나 HTML 같은 응답을 생성해서 웹 서버를 통해 다시 클라이언트에게 전달한다.

브라우저는 이 응답을 받아서 Content-Type을 기준으로 렌더링 엔진을 동작시킨다. HTML을 파싱하고, CSS를 적용하며, JavaScript를 실행해서 실제 사용자 화면을 구성한다.

또한 페이지가 렌더링된 이후에도 추가적인 리소스 요청이나 비동기 API 호출이 이루어질 수 있다. 예를 들어 이미지나 스크립트 파일을 받아오거나, 버튼 클릭 시 Ajax를 통해 서버와 통신하기도 한다.

이런 일련의 과정을 통해 하나의 웹 요청이 완전히 처리되고, 사용자에게 화면이 보이게 된다.

---

## 📁 4. 네트워크 (Computer Networks)

### Q1. HTTP와 WebSocket의 차이점은?

**A.** HTTP는 클라이언트가 요청해야만 서버가 응답하는 요청/응답 방식이며, WebSocket은 실시간 양방향 통신이 가능한 프로토콜로, 연결이 유지되며 서버가 클라이언트에 푸시할 수 있다.

### Q2. REST API란 무엇인가?

**A.** REST는 자원의 표현을 URL로 식별하고, HTTP 메서드(GET, POST, PUT, DELETE 등)를 활용하여 자원에 대한 행위를 정의하는 아키텍처 스타일이다. Stateless하고, URI 기반이며, 클라이언트-서버 구조이다.

---

## 📁 5. 데이터베이스 (Databases)

### Q1. 정규화란 무엇이고 왜 필요한가?

**A.** 정규화는 데이터 중복을 제거하고 무결성을 보장하기 위해 릴레이션을 여러 개의 테이블로 나누는 과정이다. 대표적으로 제1정규형(원자성), 제2정규형(부분 종속 제거), 제3정규형(이행 종속 제거) 등이 있다.

### Q2. 트랜잭션의 ACID란?

**A.** 트랜잭션은 일련의 작업 단위로, ACID는 다음의 속성을 말한다:

- A: 원자성(Atomicity)
    
- C: 일관성(Consistency)
    
- I: 고립성(Isolation)
    
- D: 지속성(Durability)
    

### Q3. 인덱스는 어떻게 작동하며, 단점은?

**A.** 인덱스는 일반적으로 B+ Tree를 기반으로 하며, 검색 성능을 향상시킨다. 하지만 인덱스는 삽입, 수정, 삭제 시 오버헤드가 발생하고, 잘못된 인덱스 설계는 성능 저하를 유발할 수 있다.

---

## 📁 6. 시스템 설계 (System Design)

### Q1. 트래픽이 많은 서비스를 위한 API 서버를 어떻게 확장할 것인가?

**A.** 수평 확장을 위한 로드 밸런싱, Redis 캐싱, DB 분산(샤딩, 복제), 메시지 큐를 통한 비동기 처리 등을 활용한다. 또한 CDN과 캐시 헤더를 통해 정적 리소스 부하를 줄인다.

### Q2. 마이크로서비스와 모놀리식 아키텍처의 장단점은?

**A.** 마이크로서비스는 서비스 간 분리가 가능하여 확장성과 유지보수가 뛰어나지만, 복잡한 배포 및 통신 문제가 있다. 모놀리식은 초기 개발이 간단하지만 서비스 규모가 커질수록 관리가 어려워진다.

### Q3. 백엔드 서버와 AI 모델을 어떻게 통합하는가?

**A.** 모델을 REST API로 서빙하거나, 모델을 직접 내장한 백엔드 서버를 만들 수 있다. 요청 시 모델이 추론을 수행하거나, 비동기적으로 큐 기반으로 처리할 수 있으며, 결과는 DB 또는 Redis에 저장한다.

---

## 📁 7. 형상관리 및 협업 도구

### Q1. Git에서 브랜칭 전략을 어떻게 사용하는가?

**A.** 일반적으로 `main`/`develop` 브랜치를 기준으로 기능 개발은 `feature`, 버그 수정은 `hotfix`, 배포는 `release` 브랜치를 사용하는 Git Flow 전략을 쓴다. PR 기반 코드 리뷰 후 병합한다.

### Q2. CI/CD 파이프라인이란?

**A.** CI는 코드 변경 사항을 자동으로 테스트 및 빌드하고, CD는 이를 자동으로 배포하는 파이프라인이다. GitHub Actions, Jenkins, GitLab CI 등이 사용되며, 배포 속도 및 안정성을 향상시킨다.
