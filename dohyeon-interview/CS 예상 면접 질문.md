# CS 예상 면접 질문

## 자료구조 (Data Structures)

### Q. 배열과 리스트 차이점은?
> 배열은 고정된 크기의 연속된 메모리 공간에 데이터를 저장하며, 인덱스를 통해 O(1)로 접근이 가능합니다.  
> 반면 리스트(특히 연결 리스트)는 포인터로 각 노드를 연결해 동적으로 크기를 조절할 수 있으며, 삽입과 삭제에 유리합니다.  
> 배열은 메모리 접근 속도는 빠르지만 중간 삽입/삭제 시 비용이 큽니다.  
> 리스트는 순차 접근만 가능해 검색에는 불리하지만, 삽입/삭제가 자주 발생하는 경우 적합합니다.  
> 따라서 상황에 따라 배열과 리스트를 선택해야 합니다.

### Q. 스택과 큐의 차이점은?
> 스택은 LIFO(Last In First Out) 구조로, 가장 마지막에 넣은 데이터가 먼저 나옵니다.  
> 큐는 FIFO(First In First Out) 구조로, 먼저 들어간 데이터가 먼저 나오는 방식입니다.  
> 스택은 함수 호출 시 호출 스택으로 사용되며, 깊이 우선 탐색 등에서 활용됩니다.  
> 큐는 작업 예약, 너비 우선 탐색 등에 주로 사용됩니다.  
> 두 자료구조 모두 삽입과 삭제가 제한된 방향으로만 이루어진다는 공통점이 있습니다.

### Q. 해시 테이블에서 충돌이 발생하면 어떻게 해결할 수 있는가?
> 해시 테이블에서 서로 다른 키가 같은 인덱스로 매핑되는 것을 충돌이라고 합니다.  
> 충돌 해결 방법에는 체이닝(Chaining)과 오픈 어드레싱(Open Addressing)이 있습니다.  
> 체이닝은 같은 인덱스에 연결 리스트로 여러 값을 저장하는 방식입니다.  
> 오픈 어드레싱은 빈 슬롯을 찾아 데이터를 저장하는 방법으로 선형 탐사, 이차 탐사 등이 있습니다.  
> 각각의 방식은 공간 효율성과 검색/삽입 성능에 차이가 있으며, 상황에 맞게 선택해야 합니다.

### Q. 힙 자료구조의 개념은?
> 힙은 완전 이진 트리 형태의 자료구조로, 항상 부모 노드가 자식 노드보다 크거나(최대 힙), 작아야(최소 힙) 합니다.  
> 이 특성 덕분에 최대값 또는 최소값을 빠르게 찾아야 하는 우선순위 큐(priority queue)에서 주로 사용됩니다.  
> 삽입과 삭제 연산의 시간 복잡도는 O(log n)으로 효율적입니다.  
> 배열로 구현할 수 있어 공간 활용에도 유리하며, 힙 정렬에도 활용됩니다.  
> 단, 정렬이나 검색 전반에는 적합하지 않으며, 특정한 목적에 최적화된 자료구조입니다.

---

## 알고리즘 (Algorithms)

### Q. 퀵 정렬과 병합 정렬의 개념과 차이점은?
> 퀵 정렬은 피벗을 기준으로 데이터를 분할한 뒤, 각 부분 배열을 재귀적으로 정렬하는 분할 정복 알고리즘입니다. 평균 시간 복잡도는 O(n log n)이지만, 이미 정렬된 배열에서는 O(n²)까지 성능이 떨어질 수 있습니다.
>   
> 병합 정렬은 배열을 절반씩 나누고, 각각 정렬한 뒤 병합하는 방식으로 항상 O(n log n)의 성능을 보장합니다.  
> 
> 병합 정렬은 안정 정렬이며, 퀵 정렬은 불안정 정렬입니다. 퀵 정렬은 공간 효율이 높고 실무에서 많이 사용되지만, 병합 정렬은 안정성이 필요한 경우 유리합니다.

### Q. 안정 정렬과 불안정 정렬의 차이점은?
> **안정 정렬(Stable Sort)** 은 값이 같은 요소들의 **원래 순서가 유지되는 정렬**입니다. 반면, **불안정 정렬(Unstable Sort)** 은 같은 값을 가진 요소들의 순서가 **정렬 후 바뀔 수 있습니다**.  
> 
> 예를 들어, `[A(3), B(1), C(3)]`이라는 리스트를 정렬했을 때 결과가 `[B(1), A(3), C(3)]`이면 안정 정렬입니다.  
> 
> 하지만 `[B(1), C(3), A(3)]`처럼 동일 값(A와 C)의 순서가 바뀌면 불안정 정렬입니다. 안정성이 중요한 경우(예: 여러 단계의 정렬을 하는 경우)에는 안정 정렬을 사용하는 것이 좋습니다.

### Q. 버블, 선택, 힙 정렬의 개념과 차이점은?
> 버블 정렬은 인접한 두 요소를 비교해 정렬하며 구현이 매우 단순하지만 성능이 낮습니다.  
> 선택 정렬은 가장 작은 요소를 선택해 앞쪽으로 이동시키며, 비교 횟수는 많지만 교환 횟수가 적습니다.  
> 힙 정렬은 힙 자료구조를 기반으로 하는 O(n log n) 알고리즘으로, 제자리 정렬이지만 불안정합니다.  
> 버블과 선택 정렬은 학습용으로 주로 사용되며 실제 환경에서는 잘 사용되지 않습니다.  
> 힙 정렬은 추가 공간 없이 안정적인 성능을 제공해 실무에서도 사용될 수 있습니다.

### Q. DFS와 BFS 차이점은?
> DFS(Depth-First Search)는 한 경로로 끝까지 탐색한 후 되돌아가는 방식으로, 재귀 호출이나 스택을 사용해 구현합니다.  
> BFS(Breadth-First Search)는 시작 노드에서 가까운 노드부터 순차적으로 탐색하며, 큐 자료구조를 사용합니다.  
> DFS는 백트래킹 문제나 경로 탐색 문제에 유리하며, 메모리 사용이 상대적으로 적을 수 있습니다.  
> BFS는 최단 거리 문제에서 유리하며, 노드 간의 레벨 구조나 계층 탐색이 필요할 때 적합합니다.  
> 두 알고리즘 모두 인접 리스트를 사용하면 시간 복잡도는 O(V + E)로 동일하지만, 탐색 순서와 메모리 사용 방식에서 차이가 있습니다.  
> 상황에 따라 DFS 또는 BFS를 선택하는 것이 중요합니다.


### Q. 다익스트라 알고리즘과 벨만-포드 알고리즘의 차이점은?
> 다익스트라 알고리즘은 가중치가 있는 그래프에서 최단 경로를 찾는 효율적인 알고리즘입니다.  
> 음수 가중치가 없을 때만 동작하며, 우선순위 큐를 사용해 시간 복잡도가 낮습니다.  
> 벨만-포드 알고리즘은 음수 가중치가 있는 경우에도 동작하며, 음수 사이클도 감지할 수 있습니다.  
> 다익스트라는 속도가 빠르지만 제약이 있고, 벨만-포드는 느리지만 일반적인 상황에 대응할 수 있습니다.  
> 문제의 조건에 따라 적절한 알고리즘을 선택하는 것이 중요합니다.

---
## 운영체제 (Operating Systems)

### Q. 프로세스와 스레드의 차이는?
> 프로세스는 운영체제에서 실행 중인 프로그램 단위로, 독립적인 메모리 공간을 가집니다.  
> 스레드는 프로세스 내에서 실행되는 실행 단위로, 같은 메모리 공간을 여러 스레드가 공유합니다.  
> 스레드는 생성 및 문맥 전환 비용이 낮고, 자원 공유가 용이해 병렬 처리에 적합합니다.  
> 반면, 프로세스는 서로 격리되어 있어 안정성이 높지만 자원 공유가 어렵고, 비용이 큽니다.  
> 따라서 가벼운 병렬 처리가 필요한 경우에는 스레드가 더 적합합니다.

### Q. 데드락이란 무엇이며 이를 방지하는 방법은?
> 데드락은 둘 이상의 프로세스가 서로 자원을 점유한 채 상대가 가진 자원을 기다리면서 발생하는 교착 상태입니다.  
> 네 가지 조건(상호 배제, 점유와 대기, 비선점, 순환 대기)이 모두 충족될 때 발생합니다.  
> 이를 방지하기 위해 자원 순서를 정하거나, 교착 상태가 발생하지 않도록 자원을 한꺼번에 요청하는 방식 등을 사용합니다.  
> 또는 은행가 알고리즘 같은 예방 기법이나 교착 상태 발생 후 복구하는 방법도 있습니다.  
> 설계 시 사전에 데드락 가능성을 고려하는 것이 중요합니다.

### Q. 사용자가 브라우저에서 URL을 입력했을 때, 어떤 과정을 거쳐 서버와 통신하고 응답을 받는가?
> 사용자가 브라우저에 URL을 입력하면 먼저 DNS를 통해 도메인이 IP 주소로 변환됩니다.  
> 해당 IP로 TCP 3-way 핸드셰이크가 수행되어 연결이 설정되고, 브라우저는 HTTP(S) 요청을 전송합니다.  
> 요청은 먼저 **Web 서버(Nginx, Apache 등)** 에 도달하며, 정적 파일은 Web 서버가 직접 응답합니다.  
> 동적 요청의 경우 Web 서버는 이를 **WAS(Web Application Server)** 로 전달하고, WAS는 애플리케이션 로직을 실행해 응답을 생성합니다.  
> WAS는 DB 조회나 외부 API 호출 등을 처리해 HTML 또는 JSON과 같은 응답을 생성합니다.  
> 응답은 다시 Web 서버를 거쳐 브라우저에 도달하고, 브라우저는 HTML, CSS, JS 등을 파싱하여 화면에 렌더링합니다.  
> 이 과정에서 CDN, 브라우저 캐시 등의 최적화 기술이 성능에 영향을 미칠 수 있습니다.  
> 전체 요청-응답 흐름은 수백 밀리초 내에 빠르게 완료되며, 클라이언트와 서버 사이에는 다양한 계층이 협업합니다.

### Q. TCP와 UDP의 차이점은 무엇이고, 백엔드에서는 각각 어떤 상황에서 사용하는지?
> TCP는 연결 기반의 프로토콜로 신뢰성과 순서를 보장하며, 흐름 제어와 혼잡 제어 기능도 포함됩니다.  
> 반면 UDP는 비연결형으로 신뢰성은 없지만 전송 속도가 빠르고 오버헤드가 적습니다.  
> 백엔드에서는 웹 서버, DB 서버 등 정확한 데이터 전송이 중요한 경우 TCP를 사용합니다.  
> 반면, 실시간 스트리밍이나 게임 서버처럼 일부 데이터 손실이 허용되면서 지연이 중요한 경우 UDP가 적합합니다.  
> 선택은 서비스의 요구사항에 따라 달라집니다.

### Q. CPU Context Switching이란 무엇이고, 왜 비용이 발생하나요?
> Context Switching은 CPU가 하나의 프로세스나 스레드에서 다른 작업으로 전환할 때 발생하는 작업입니다.  
> 현재 실행 중인 작업의 상태(레지스터, 프로그램 카운터 등)를 저장하고, 다음 작업의 상태를 복원합니다.  
> 이 과정에는 메모리 접근, 커널 모드 전환 등의 오버헤드가 발생해 성능 저하를 초래할 수 있습니다.  
> 특히 빈번한 스위칭은 캐시 무효화 등의 이유로 성능에 악영향을 줄 수 있습니다.  
> 따라서 컨텍스트 스위칭 횟수를 최소화하는 스레드/프로세스 구조 설계가 중요합니다.

---

## 네트워크 (Computer Networks)

### Q. HTTP와 HTTPS의 차이점은?
> HTTP는 데이터를 암호화하지 않고 전송하는 프로토콜이며, 기본 포트는 80번입니다.  
> HTTPS는 SSL/TLS를 기반으로 데이터를 암호화하여 전송하며, 기본 포트는 443번입니다.  
> HTTPS는 기밀성, 무결성, 인증을 보장해 중간자 공격(MITM) 등 보안 위협에 대응할 수 있습니다.  
> 최근 대부분의 웹사이트는 보안을 위해 HTTPS를 기본으로 사용합니다.  
> HTTPS는 최초에 TLS 핸드셰이크 과정이 추가되므로 약간의 오버헤드가 발생합니다.

### Q. HTTP와 WebSocket의 차이점은?
> HTTP는 요청/응답 기반의 단방향 통신 모델이며, 클라이언트가 요청을 보내야 서버가 응답합니다.  
> WebSocket은 양방향 통신이 가능한 프로토콜로, 한 번 연결이 성립되면 실시간 데이터 송수신이 가능합니다.  
> HTTP는 REST API 기반의 데이터 통신에 적합하며, WebSocket은 채팅, 실시간 알림 등 이벤트 중심 애플리케이션에 적합합니다.  
> WebSocket은 핸드셰이크 시 HTTP를 사용하지만 이후에는 별도의 프로토콜로 동작합니다.  
> 성능과 실시간성이 중요한 경우 WebSocket이 선호됩니다.

### Q. REST API란 무엇인가?
> REST API는 자원을 URI로 표현하고, HTTP 메서드(GET, POST, PUT, DELETE 등)를 통해 해당 자원을 조작하는 방식입니다.  

### Q. 동기(Synchronous)와 비동기(Asynchronous)의 차이는 무엇인가요?
> 동기(Synchronous) 방식은 요청한 작업이 끝날 때까지 다음 작업을 기다리는 방식입니다.  
> 반면 비동기(Asynchronous)는 요청을 보내고, 결과를 기다리는 동안 다른 작업을 먼저 수행할 수 있는 구조입니다.  
> 예를 들어 파일을 읽는 작업에서, 동기는 파일이 모두 읽힐 때까지 코드 실행이 멈추지만, 비동기는 파일을 읽는 동안 다음 코드가 먼저 실행됩니다.  
> 웹 서버에서는 비동기 방식이 많으며, 특히 Node.js 기반 서버는 이벤트 루프를 통해 비동기 요청을 효율적으로 처리합니다.  
> 비동기는 많은 요청을 동시에 처리할 수 있어, 대기 시간을 줄이고 서버 자원을 효율적으로 활용할 수 있는 장점이 있습니다.  
> 상황에 따라 동기가 더 단순하거나 적합한 경우도 있으므로, 두 방식을 적절히 구분해서 사용하는 것이 중요합니다.


---

## 데이터베이스 (Databases)

### Q. 인덱스는 어떻게 작동하며, 왜 필요한지, 그리고 단점은?
> 인덱스는 테이블의 특정 컬럼 값을 기준으로 정렬된 데이터 구조(B-tree 등)를 유지해 검색 성능을 높입니다.  
> 쿼리 시 전체 테이블을 순회하는 대신 인덱스를 통해 빠르게 레코드를 찾을 수 있어 성능이 크게 향상됩니다.  
> 하지만 인덱스는 추가적인 저장 공간을 차지하고, INSERT/UPDATE/DELETE 시 성능 저하를 유발할 수 있습니다.  
> 너무 많은 인덱스를 만들면 쓰기 성능이 크게 나빠질 수 있으므로, 사용 빈도에 따라 적절히 설계해야 합니다.  
> 일반적으로 WHERE 조건에 자주 등장하거나 JOIN/ORDER BY에 사용되는 컬럼에 인덱스를 걸어줍니다.

### Q. 정규화란 무엇이고 왜 필요한가?
> 정규화는 데이터 중복을 제거하고 무결성을 보장하기 위해 테이블을 구조적으로 분해하는 과정입니다.  
> 제1정규형부터 보통 제3정규형까지 적용되며, 각 단계는 종속성과 중복을 최소화하는 목적을 가집니다.  
> 이를 통해 저장 공간을 절약하고 데이터 변경 시 일관성을 유지할 수 있습니다.  
> 하지만 지나친 정규화는 JOIN이 많아져 성능 저하를 유발할 수 있습니다.  
> 따라서 성능과 유지보수 사이에서 적절한 균형을 유지해야 합니다.

### Q. 트랜잭션의 ACID란?
> ACID는 트랜잭션의 4가지 핵심 속성인 원자성(Atomicity), 일관성(Consistency), 고립성(Isolation), 지속성(Durability)을 의미합니다.  
> 원자성은 트랜잭션 내 작업이 전부 성공하거나 전부 실패해야 함을 보장합니다.  
> 일관성은 트랜잭션 수행 전후에 데이터의 정합성이 유지되어야 함을 의미합니다.  
> 고립성은 동시에 여러 트랜잭션이 수행되더라도 서로 간섭하지 않도록 보장합니다.  
> 지속성은 트랜잭션이 커밋되면 결과가 영구적으로 저장되는 성질입니다.

### Q. ORM을 사용하면서 생길 수 있는 문제점은 무엇인가?
> ORM은 객체와 테이블 간의 매핑을 자동화해 개발 생산성을 높이지만, 성능 문제가 발생할 수 있습니다.  
> 대표적으로 N+1 쿼리 문제, 불필요한 Lazy 로딩, 과도한 JOIN 등이 성능을 저하시키는 원인이 됩니다.  
> 또한 쿼리 튜닝이 어렵고, 복잡한 쿼리는 오히려 ORM보다 SQL이 더 명확할 수 있습니다.  
> ORM 사용 시 쿼리 최적화와 로딩 전략에 대한 이해가 필요합니다.  
> 무분별한 사용은 오히려 유지보수와 성능 측면에서 리스크가 됩니다.

### Q. 트랜잭션 격리 수준(Isolation Level)의 종류와 차이점은?
> 트랜잭션 격리 수준은 여러 트랜잭션이 동시에 접근할 때 발생할 수 있는 문제(Dirty Read, Phantom Read 등)를 제어하는 정도입니다.  
> ANSI SQL 기준으로 Read Uncommitted, Read Committed, Repeatable Read, Serializable이 있으며, 위로 갈수록 격리 수준이 강해집니다.  
> Read Uncommitted는 가장 낮은 수준으로, 커밋되지 않은 데이터를 읽을 수 있습니다.  
> Repeatable Read는 같은 쿼리에 대해 항상 같은 결과를 보장하지만 팬텀 리드를 막지 못합니다.  
> Serializable은 가장 높은 수준으로, 동시성은 낮지만 완전한 일관성을 제공합니다.

### Q. OneToMany, ManyToOne 관계를 어떻게 정의하고, 어떤 문제에 주의해야 하는지?
> OneToMany는 하나의 엔티티가 여러 개의 자식 엔티티를 가질 수 있는 관계이고, ManyToOne은 그 반대입니다.  
> 예를 들어 게시글과 댓글 관계에서, 하나의 게시글은 여러 댓글을 가질 수 있으므로 OneToMany입니다.  
> ORM에서는 연관 관계 설정 시 양방향인지 단방향인지, fetch 전략이 Lazy인지 Eager인지 주의해야 합니다.  
> 양방향 관계에서는 순환 참조로 인해 무한 루프가 발생할 수 있으며, DTO 분리나 `@JsonIgnore` 등으로 해결합니다.  
> 또한 연관된 엔티티가 많을 경우 쿼리 성능 이슈에 유의해야 합니다.

---
## 시스템 설계 (System Design) & NestJS & React

### Q. 트래픽이 많은 서비스를 위한 API 서버를 어떻게 확장할 것인가?
> 트래픽이 많은 서비스를 위해 먼저 **수평 확장(horizontal scaling)** 을 고려합니다.  
> 여러 서버 인스턴스를 띄우고 로드 밸런서를 이용해 트래픽을 분산합니다.  
> 캐싱(Redis, CDN 등)을 적극 활용해 요청을 줄이고 응답 속도를 향상시킵니다.  
> 데이터베이스도 읽기/쓰기 분리, 샤딩 등을 통해 확장성을 높입니다.  
> 최종적으로는 무상태(stateless) 서버 구조와 클라우드 기반 오토스케일링 도입을 검토합니다.

### Q. Docker에서 container, image, compose는 무엇인가요?
> **Docker Image**는 컨테이너를 만들기 위한 실행 가능한 패키지로, 애플리케이션 코드, 런타임, 라이브러리, 환경 설정 등이 포함되어 있습니다.  
> 쉽게 말하면 "컨테이너의 설계도" 같은 개념이며, 하나의 이미지로 여러 개의 컨테이너를 만들 수 있습니다.  
> **Docker Container**는 이미지로부터 생성된 실제 실행 환경으로, 독립적으로 실행되며 격리된 파일 시스템과 네트워크를 가집니다.  
> 즉, 컨테이너는 이미지의 인스턴스이며, 이미지가 정적이라면 컨테이너는 동적입니다.  
> **Docker Compose**는 여러 개의 컨테이너를 정의하고 함께 실행할 수 있게 해주는 도구로, 주로 `docker-compose.yml` 파일을 사용합니다.  
> 예를 들어 백엔드, 데이터베이스, 캐시 서버 등 여러 서비스를 동시에 띄우고 관리할 때 유용합니다.

### Q. Redis는 어떤 상황에서 사용하는지?
> Redis는 인메모리 데이터 저장소로, 빠른 읽기/쓰기가 필요한 경우에 사용됩니다.  
> 주로 세션 관리, 캐싱, 실시간 데이터 처리(예: 랭킹, 카운터), Pub/Sub 메시징 등에 활용됩니다.  
> 데이터는 메모리에 저장되기 때문에 디스크 기반 DB보다 성능이 매우 뛰어납니다.  
> 하지만 영속성이 약하므로 중요한 데이터는 RDB와 함께 사용해야 합니다.  
> TTL을 지정해 자동 만료가 필요한 경우에도 유용하게 사용됩니다.

### Q. NestJS는 왜 싱글 스레드인데도 실무에서 사용하는가?
> NestJS는 싱글 스레드이지만, **비동기 논블로킹 방식**으로 병렬 작업처럼 동시성을 구현합니다.
> I/O 작업(예: DB 조회, 파일 읽기, API 호출 등)은 **이벤트 루프와 비동기 콜백**을 통해 효율적으로 처리할 수 있습니다.
> 이는 Java의 멀티스레딩처럼 병렬 처리되는 건 아니지만, 대부분의 웹 서버에서 발생하는 I/O 중심 작업은 동시에 처리 가능하다는 뜻입니다.  
> 또한 Node.js는 `cluster`나 `worker_threads` 같은 기능으로 멀티 스레딩이나 멀티 프로세싱 구조도 구성할 수 있습니다.
>
> 쉽게 말해, 웹 서버의 주 작업인 **I/O(입출력)** 은 오래 걸릴 수 있기 때문에, Node는 요청만 하고 결과 기다리는 동안 **다른 요청을 먼저 처리**하기 때문에 효율적으로 task를 처리할 수 있습니다.

### Q. React에서 상태(state)란 무엇이고, 왜 필요한지?
> 상태(state)는 컴포넌트 내부에서 관리되는 동적인 데이터입니다.  
> 사용자 입력, 서버 응답 등 외부 이벤트에 따라 컴포넌트가 변화해야 할 때 상태를 사용합니다.  
> 상태가 변경되면 React는 해당 컴포넌트를 다시 렌더링해 UI를 자동으로 업데이트합니다.  

### Q. props와 state의 차이는 무엇인지?
> `props`는 부모 컴포넌트가 자식 컴포넌트에 전달하는 **읽기 전용 데이터**입니다.  
> `state`는 컴포넌트 내부에서 **직접 관리**되며, 변경이 가능하고 UI 업데이트를 유발합니다.  
> props는 외부로부터 전달되며, 재사용성과 컴포넌트 간 의존 관계를 형성합니다.  
> 반면 state는 컴포넌트의 동작과 UI 상태를 표현하는 데 사용됩니다.  
> 이를 통해 React는 단방향 데이터 흐름을 유지합니다.

### Q. 로드 밸런서와 리버스 프록시의 차이점은?
> 로드 밸런서는 여러 서버에 트래픽을 **분산**해 부하를 줄이는 장치입니다.  
> 리버스 프록시는 클라이언트의 요청을 받아 백엔드 서버로 **중계**하는 역할을 하며, 보안, 캐싱, 라우팅도 지원합니다.  

### Q. 마이크로서비스와 모놀리식 아키텍처의 장단점은?
> **모놀리식 아키텍처**는 한 프로젝트에 모든 기능이 통합되어 있어 개발과 배포가 단순하지만, 서비스가 커질수록 유지보수가 어려워집니다.  
> **마이크로서비스 아키텍처**는 각 기능을 독립적인 서비스로 분리해 유연한 확장성과 장애 격리를 제공합니다.  
> 그러나 서비스 간 통신, 배포 복잡성, 데이터 일관성 유지 등의 어려움이 있습니다.  
> 작은 팀이나 초기 프로젝트에서는 모놀리식이 적합하고, 규모가 커지면 마이크로서비스를 고려할 수 있습니다.  
> 아키텍처 선택은 조직 규모, 개발 인프라, 유지보수 역량 등을 고려해 결정합니다.

### Q. 백엔드 서버와 AI 모델을 어떻게 통합하는가?
> 백엔드 서버는 AI 모델을 REST API 또는 gRPC 형태로 호출하는 방식으로 통합합니다.  
> 모델은 별도의 서버에서 Python(Flask, FastAPI 등)으로 띄우고, 백엔드는 HTTP로 요청을 보냅니다.  
> 모델이 무겁거나 응답 시간이 중요한 경우 비동기 큐(RabbitMQ, Kafka 등)와 워커를 활용합니다.  
> 모델 서버는 컨테이너(Docker)로 패키징하고, GPU 리소스가 필요한 경우 클라우드 인프라를 사용합니다.  
> 요청-응답 처리뿐 아니라 모델 로깅, 모니터링도 함께 고려해야 합니다.

### Q. NestJS에서 RDBMS 연동을 위해 TypeORM을 사용하는 이유는?
> TypeORM은 TypeScript 기반 ORM으로 NestJS와 자연스럽게 통합됩니다.  
> 엔티티(Entity) 클래스 기반으로 테이블을 정의하고, 쿼리 작성 없이도 DB 연동이 가능합니다.  
> Repository 패턴과 데코레이터 기반 문법이 NestJS 아키텍처와 잘 어울립니다.  
> 마이그레이션, 관계 설정, Lazy/Eager 로딩 등 기능도 풍부하게 제공됩니다.  
> NestJS에서 일관된 모듈 구조로 DB를 다루기 위해 TypeORM을 주로 사용합니다.

### Q. 서비스 계층(Service Layer)의 역할은 무엇이고, 왜 필요한지?
> 서비스 계층은 컨트롤러와 데이터 액세스 계층(Repository 등) 사이에서 **비즈니스 로직을 처리**하는 중간 계층입니다.  
> 이 계층을 통해 비즈니스 규칙을 재사용 가능하고 테스트 가능한 형태로 분리할 수 있습니다.  
> 컨트롤러는 요청/응답 처리에만 집중하고, DB 접근 로직은 repository에 위임합니다.  
> 코드의 유지보수성과 관심사 분리를 높이는 데 필수적인 구조입니다.  
> NestJS에서는 `@Injectable()` 데코레이터를 통해 서비스 클래스를 정의합니다.

### Q. 상태 관리를 위한 전역 상태 관리 도구는 어떤 것들이 있고, 언제 사용하는지?
> 대표적인 전역 상태 관리 도구로는 Redux, Recoil, Zustand, MobX 등이 있습니다.  
> 여러 컴포넌트에서 같은 상태를 공유하거나, 복잡한 상태 전이를 처리할 때 사용합니다.  
> Redux는 가장 전통적인 구조로, 액션과 리듀서로 상태를 명확히 관리합니다.  
> Recoil과 Zustand는 비교적 가볍고 학습 비용이 낮아 최근 선호됩니다.  
> 앱의 규모나 상태 복잡도에 따라 도구를 선택해야 하며, 작은 앱에서는 useContext와 useReducer로도 충분할 수 있습니다.

---
## 보안 (Security)

### Q. JWT란 무엇이고, 어떻게 인증에 사용되는가?
> JWT(JSON Web Token)는 클라이언트와 서버 간의 인증 정보를 담은 토큰입니다.  
> 주로 access token으로 사용되며, **header**, **payload**, **signature** 세 부분으로 구성됩니다.  
> `header`는 토큰의 타입과 해싱 알고리즘 정보를 담고 있으며,  
> `payload`는 사용자 정보나 권한, 만료 시간 등의 실제 데이터를 포함합니다.  
> `signature`는 header와 payload를 기반으로 서버의 비밀 키로 서명된 값으로, 토큰 위조 여부를 검증하는 데 사용됩니다.  
> 사용자는 로그인 후 JWT를 발급받고, 이후 요청의 Authorization 헤더에 포함하여 인증을 대신합니다.  
> 서버는 서명을 검증해 신뢰성을 확인하고, 별도의 세션 저장 없이 stateless하게 사용자 인증이 가능합니다.  
> 확장성과 유연성이 좋아 RESTful API 인증 방식에서 널리 사용됩니다.

### Q. JWT를 사용할 때 주의해야 할 보안 이슈는 무엇인가?
> JWT는 클라이언트에 저장되므로 노출되면 탈취 위험이 있습니다.  
> 반드시 HTTPS를 통해 전달하고, access token은 가능한 한 수명을 짧게 유지해야 합니다.  
> 토큰 서명 검증에 사용되는 알고리즘 설정은 신중히 해야 하며, none 알고리즘 허용은 보안 취약점입니다.  
> 토큰 탈취에 대비해 refresh token과 함께 사용하는 것이 일반적입니다.  
> XSS나 로컬 저장소 접근을 통한 노출도 방지해야 합니다.

### Q. 세션 기반 인증과 토큰 기반 인증(JWT)의 차이점은?
> 세션 기반 인증은 서버가 세션 ID를 저장하고, 클라이언트는 쿠키를 통해 이를 유지합니다.  
> 반면 토큰 기반 인증(JWT)은 서버가 상태를 저장하지 않고, 클라이언트가 토큰 자체를 보관합니다.  
> 세션 방식은 중앙 집중형 구조에 적합하고, JWT는 분산 시스템에서 유리합니다.  
> 세션은 서버 메모리를 사용하므로 확장성이 떨어지지만, 보안 관리가 용이합니다.  
> JWT는 stateless한 구조로 성능은 좋지만, 탈취 시 위험성이 크므로 보안 강화가 필요합니다.

### Q. OAuth 2.0의 동작 원리와 사용하는 이유는?
> OAuth 2.0은 타사 서비스의 리소스 접근 권한을 사용자 인증 없이 위임할 수 있게 해주는 프로토콜입니다.  
> 사용자 인증 후 권한 부여 코드를 받아 access token을 발급받고, 이를 통해 API를 호출합니다.  
> 자원 소유자, 클라이언트, 인증 서버, 자원 서버 간의 역할이 명확히 구분되어 있습니다.  
> 주로 소셜 로그인, 결제 API 연동 등에서 사용되며, 안전하게 권한 위임이 가능합니다.  
> refresh token을 사용해 장기적인 인증도 구현할 수 있습니다.

### Q. HTTPS가 보안을 보장하는 방식은?
> HTTPS는 HTTP에 SSL/TLS 프로토콜을 적용해 데이터를 암호화하여 전송합니다.  
> 이로써 중간자 공격(MITM)이나 패킷 스니핑 등의 공격을 방지할 수 있습니다.  
> 클라이언트와 서버는 공개키 기반의 핸드셰이크를 통해 세션 키를 생성하고, 이후 대칭키로 암호화된 통신을 합니다.  
> 또한 서버 인증서를 통해 신뢰할 수 있는 서버와만 통신이 이루어지도록 합니다.  
> 보안을 위해 모든 웹사이트는 HTTPS를 사용하는 것이 필수입니다.

### Q. XSS(Cross Site Scripting)란 무엇이며, 이를 방지하는 방법은?
> XSS는 공격자가 악성 스크립트를 웹 페이지에 삽입해 다른 사용자의 브라우저에서 실행시키는 공격입니다.  
> 이를 통해 쿠키 탈취, 세션 하이재킹, 피싱 등이 발생할 수 있습니다.  
> 방지 방법으로는 사용자 입력을 철저히 검증하고, HTML 이스케이프 처리, CSP(Content Security Policy) 적용 등이 있습니다.  
> React 등 프론트엔드 프레임워크는 기본적으로 XSS를 막아주는 기능을 제공합니다.  
> 서버에서도 출력 시 escaping을 철저히 해야 안전합니다.

### Q. CSRF(Cross Site Request Forgery)란 무엇이며, 이를 방지하는 방법은?
> CSRF는 사용자가 의도하지 않은 요청을 공격자가 대신 전송하게 만드는 공격입니다.  
> 예를 들어 사용자가 로그인 상태일 때 공격자가 악성 링크를 클릭하면, 서버가 권한 있는 요청으로 오인할 수 있습니다.  
> 방지 방법으로는 CSRF 토큰 사용, Referer 검증, SameSite 쿠키 속성 설정 등이 있습니다.  
> 특히 SameSite=Strict 또는 Lax 설정은 브라우저가 타 도메인 요청 시 쿠키 전송을 제한합니다.  
> 민감한 요청은 POST 방식과 함께 CSRF 보호를 적용해야 합니다.

### Q. 비밀번호 저장 시 해시(Hashing)를 사용하는 이유는?
> 비밀번호를 평문으로 저장하면 데이터 유출 시 큰 보안 사고로 이어질 수 있습니다.  
> 해싱은 단방향 암호화로, 해시값으로부터 원래의 값을 역산할 수 없습니다.  
> 이를 통해 비밀번호를 안전하게 저장할 수 있으며, 로그인 시 입력한 비밀번호를 해싱하여 비교합니다.  
> 보안 강화를 위해 bcrypt, scrypt, Argon2 같은 해시 함수와 솔트(salt)를 함께 사용하는 것이 일반적입니다.  
> 해시는 암호화와 달리 복호화할 수 없는 특성을 가집니다.

### Q. SQL Injection이란 무엇이고, 이를 방지하려면 어떻게 해야 하는가?
> SQL Injection은 사용자 입력을 통해 악의적인 SQL 코드를 삽입해 DB를 조작하는 공격입니다.  
> 예를 들어 로그인 쿼리에 `'OR 1=1 --` 같은 입력을 넣어 인증 우회를 시도할 수 있습니다.  
> 방지하려면 Prepared Statement나 ORM의 파라미터 바인딩을 사용해 쿼리를 분리해야 합니다.  
> 사용자 입력 검증, 최소 권한 원칙 적용, 에러 메시지 노출 방지도 중요합니다.  
> 입력 값을 직접 SQL에 삽입하는 방식은 피해야 합니다.

### Q. CORS란 무엇이며, 어떻게 설정하고 왜 필요한가?
> CORS(Cross-Origin Resource Sharing)는 브라우저가 다른 출처(origin)로부터 리소스를 요청할 때 보안을 위해 제약을 거는 정책입니다.  
> 기본적으로 브라우저는 동일 출처 정책(SOP)을 적용하며, 다른 출처 요청은 CORS 정책을 통해 허용해야 합니다.  
> 서버는 `Access-Control-Allow-Origin` 헤더를 통해 특정 출처를 허용할 수 있습니다.  
> 인증이 필요한 요청은 `withCredentials`, `Access-Control-Allow-Credentials` 등의 추가 설정이 필요합니다.  
> CORS는 클라이언트와 서버가 서로 다른 도메인에 있을 때 필수적인 설정입니다.

---

## 형상관리 및 협업 도구

### Q. Git에서 브랜칭 전략을 어떻게 사용하는가?
> Git에서는 기능 개발, 배포, 유지보수를 분리하기 위해 브랜칭 전략을 사용합니다.  
> 가장 대표적인 전략은 Git Flow로, `main`, `develop`, `feature`, `release`, `hotfix` 브랜치를 나눠 작업합니다.  
> 또는 GitHub Flow처럼 단순하게 `main`과 `feature` 브랜치만 사용하는 방식도 있습니다.  
> PR 기반 코드 리뷰와 CI 연동을 통해 안정적인 배포가 가능합니다.  
> 팀 규모와 개발 주기에 맞는 브랜칭 전략을 선택하는 것이 중요합니다.

### Q. CI/CD 파이프라인이란?
> CI/CD는 지속적 통합(Continuous Integration)과 지속적 배포(Continuous Delivery/Deployment)를 의미합니다.  
> 개발자가 코드를 push하면 자동으로 빌드, 테스트, 배포까지 수행하는 자동화된 흐름입니다.  
> 이를 통해 배포 오류를 줄이고, 빠르게 새로운 기능을 사용자에게 전달할 수 있습니다.  
> Jenkins, GitHub Actions, GitLab CI, CircleCI 등이 대표적인 도구입니다.  
> DevOps 문화의 핵심 요소로, 품질과 개발 속도를 모두 높일 수 있습니다.
